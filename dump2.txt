package  {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.Shape;
	import flash.display.Sprite;
	import flash.events.Event;
	import flash.events.KeyboardEvent;
	import flash.events.MouseEvent;
	import flash.ui.Keyboard;
	import flash.net.*;
	import flash.utils.*;
	import flash.text.TextField;
	import metaswarm.ui.hoverlabel.HoverLabel;
	import metaswarm.ui.sidebar.Sidebar;
	import metaswarm.swarm.Swarm;
	import metaswarm.build.Builder;
	import metaswarm.control.Controller;
	import metaswarm.build.Preloader;
	import metaswarm.control.Router;
	import metaswarm.ui.Ui;
	
	[SWF(width='1200',height='900',backgroundColor='#ffffff',frameRate='25')]

    public class Metaswarm extends Sprite
    {
		//declarations
		private var _preloader:Preloader;
		private var _builder:Builder;
		private var _router:Router;
		private var _controller:Controller;
		private var _ui:Ui;				
		
        public function Metaswarm():void
		{
			ui = new Ui();
			builder = new Builder(this);
			preloader = new Preloader(builder);
			controller = new Controller(ui); //removed hoverLabel param
			router = new Router(controller);
			
			init();	
		}

		private function init():void
		{
			//this.stage.quality = "low";
			
			//register ui listeners
			addEventListener(Event.ENTER_FRAME, router.onEnterFrame);
			stage.addEventListener(KeyboardEvent.KEY_DOWN, router.onkeyDown);
			stage.addEventListener(KeyboardEvent.KEY_UP, router.onkeyUp);
			addEventListener(MouseEvent.CLICK, router.onMouseClick);
			addEventListener(MouseEvent.MOUSE_DOWN, router.onMouseDown);
			addEventListener(MouseEvent.MOUSE_UP, router.onMouseUp);
			addEventListener(MouseEvent.MOUSE_OVER, router.onMouseOver);
			addEventListener(MouseEvent.MOUSE_OUT, router.onMouseOut);
			
			//add ui stage
			addChild(ui);
		}
		
		public function get controller():Controller
		{
			return _controller;
		}
		
		public function set controller(value:Controller):void
		{
			_controller = value;
		}

		public function get router():Router
		{
			return _router;
		}

		public function set router(value:Router):void
		{
			_router = value;
		}

		public function get builder():Builder
		{
			return _builder;
		}

		public function set builder(value:Builder):void
		{
			_builder = value;
		}

		public function get preloader():Preloader
		{
			return _preloader;
		}

		public function set preloader(value:Preloader):void
		{
			_preloader = value;
		}
		public function get ui():Ui
		{
			return _ui;
		}

		public function set ui(value:Ui):void
		{
			_ui = value;
		}

		
    }//end class
}//end pkg
package     {
	import flash.display.DisplayObject;
	import flash.display.Sprite;
	import metaswarm.node.components.dot.Dot;
	import metaswarm.node.components.icon.Icon;
	import metaswarm.node.nodestates.DraggingState;
	import metaswarm.node.nodestates.DroppedState;
	import metaswarm.node.nodestates.IdleState;
	import metaswarm.node.nodestates.PickedState;
	import metaswarm.node.nodestates.PoppedState;
	import metaswarm.node.nodestates.ThumbDraggingState;
	import metaswarm.node.components.databox.DataBox;
	import metaswarm.node.components.tag.Tag;
	import metaswarm.node.components.thumb.Thumb;
	import metaswarm.node.NodeState;
	
	public class Node extends Sprite{
		
		//omit constants for now
		//var nodeLoader:NodeLoader;
		
		public var dat:Array; //again using key word
		
		//var dat:Array;
		public var xpos:Array;
		public var ypos:Array;
		//var xtmp:Array;
		//var ytmp:Array;
		
		//internal composite objects
		public var thumb:Thumb;
		public var icon:Icon;
		public var dot:Dot;
		public var tag:Tag;
		public var dataBox:DataBox;
		//var img:Image;
		
		//internal states
		public var idle:NodeState;
		public var picked:NodeState;
		public var dragging:NodeState;
		public var dropped:NodeState;
		public var tdragging:NodeState;
		public var popped:NodeState;
		
		//internal state holder
		public var nodeState:NodeState;
		public var prevState:NodeState;
		
		//constructor:
		public function Node(){
			
			//rediculous but don't know how else to initialize an exact-sized 2d array
			xpos = new Array(new Array(), new Array(), new Array(), new Array(), new Array(), new Array(), new Array(), new Array(), new Array());
			ypos = new Array(new Array(), new Array(), new Array(), new Array(), new Array(), new Array(), new Array(), new Array(), new Array());
			
			//nodeLoader = new NodeLoader(this);

			idle = new IdleState(this);
			picked = new PickedState(this);
			dragging = new DraggingState(this);
			tdragging = new ThumbDraggingState(this);
			dropped = new DroppedState(this);
			popped = new PoppedState(this);
			
			dot = new Dot();
			icon = new Icon();
			thumb = new Thumb();
			tag = new Tag();
			dataBox = new DataBox();
			//img = new Image();
			
			init();
		}
		public function init():void{
			nodeState = idle;
		}
		/*function load():void{
			//trace("node.load()");
			nodeLoader.load();
		}
		function make():void{
			//trace("node.make()");
			nodeLoader.make();
		}
		function go():void{
			//trace("node.go()");
			nodeLoader.go();
		}*/
		
		//should this be delegated???--no!
		public function popout():void{
			nodeState.popout();
		}
		
		public function popin():void{
			nodeState.popin();
		}
		
		public function close():void{
			nodeState.close();
		}
		
		public function isIdle():Boolean{
			//trace("isidle?");
			if(nodeState == idle){
				return true;
			}else{
				return false;
			}
		}
		
		public function isPicked():Boolean{
			if(nodeState == picked){
				return true;
			}else{
				return false;
			}
		}
		
		public function isDropped():Boolean{
			if(nodeState == dropped){
				return true;
			}else{
				return false;
			}
		}
		
		public function isPopped():Boolean{
			if(nodeState == popped){
				return true;
			}else{
				return false;
			}
		}
		
		/*function loadData(dat:Array):void{
			tag.dat = dat;
			meta.dat = dat;
			meta.format();
			var path:String = String(dat[0] + dat[1]);
			//img.loadImg(path);
		}
		
		function loadImg():void{
			var path:String = String(meta.dat[0] + meta.dat[1]);
			img.loadImg(path);
		}*/
		
		public function select():void{
			//trace("node delegate select");
			nodeState.select();
		}
		
		public function deSelect():void{
			nodeState.deSelect();
		}
		
		public function toggleSelect():void{
			nodeState.toggleSelect();
		}
		
		public function drag():void{
			//trace("node delegate drag");
			nodeState.drag();
		}
		
		public function drop():void{
			//trace("node delegate drop");
			nodeState.drop();
		}
		
		//change to setTarget
		public function setTarget(pid:uint, sid:uint):void{
			//trace("node set Target");
			nodeState.setTarget(xpos[pid][sid], ypos[pid][sid]);
		}
		
		public function rePosition():void{
			//trace("node delegate rePosition");
			nodeState.rePosition();
		}
		
		public function reSize():void{
			//trace("node delegate reSize");
			nodeState.reSize();
		}
		
		public function startFocus():void{
			//trace("");
			nodeState.startFocus();
		}
		
		public function stopFocus():void{
			//trace("");
			nodeState.stopFocus();
		}
		
		public function startHover():void{
			//trace("");
			nodeState.startHover();
		}
		
		public function stopHover():void{
			//trace("");
			nodeState.stopHover();
		}
		
		public function incrTag():void{
			tag.incr();
		}
		
		public function decrTag():void{
			tag.decr();
		}
	}
}
		
		
package metaswarm.build {
    import flash.display.*;
	import flash.events.*;
	import flash.ui.Keyboard;
	import flash.net.*;
	import flash.utils.*;
	import flash.text.*;
	import metaswarm.ui.hoverlabel.LabelMaker;
	import metaswarm.ui.sidebar.SidebarMaker;
	import metaswarm.swarm.patternmaker.PatternMaker;
	import metaswarm.swarm.SwarmLoader;
	import metaswarm.ui.UiLoader;
	import metaswarm.*;

	//import fl.controls.Label;

    public class Builder extends Sprite
    {
		private var _gnurbwurk:Metaswarm;
		private var _uiLoader:UiLoader;

        public function Builder(_gnurbwurk:Metaswarm):void
		{
			this._gnurbwurk = _gnurbwurk;
			this._uiLoader = new UiLoader(_gnurbwurk.ui);
			
			init();
		}
		private function init():void
		{ 
			//
		}		
		public function load(dat:Array):void
		{
			//load parsed data into objects
			_uiLoader.load(dat);
		}
		public function make():void
		{
			//make views
			_uiLoader.make();
		}
		public function go():void
		{
			//add grandchildren to display
			_uiLoader.go();
		}
		
    }//end class
}//end pkg
package metaswarm.build {
  import flash.display.*;
  import flash.text.*;
  import flash.events.*
  import flash.net.*;
  
  public class DataLoader extends Sprite {
	  
	private var _loadProg:TextField;  
	private var _preloader:Preloader;
	
    public function DataLoader(preloader:Preloader) 
	{
		this._preloader = preloader;
		this._loadProg = new TextField();
		
		init();
    }
    
    private function init():void 
	{ 
      	//loadProg.width = stage.stageWidth;
      	//loadProg.height = stage.stageHeight;   
      	addChild(_loadProg);  
    }
	
	public function preload():void {
			  
		var loader:URLLoader = new URLLoader();
			  
		// Instruct the loader to read the file as plain text - This line is not
		// necessary because the dataFormat is DataFormat.TEXT by default.
		loader.dataFormat = URLLoaderDataFormat.TEXT;
			  
		// Register an event handler for when the data is finished downloading
		loader.addEventListener(Event.COMPLETE, loadComplete);
		
		// Listen for the progress event to check download progress
      	loader.addEventListener(ProgressEvent.PROGRESS, handleProgress);
 
		// Load the HTML text from the example.html file
		loader.load(new URLRequest("index5.txt"));
    }
		
	private function handleProgress(event:ProgressEvent):void 
	{
      	// Calculate the percentage by multiplying the loaded-to-total 
      	// ratio by 100
      	var percent:Number = Math.round(event.bytesLoaded 
                                      / event.bytesTotal * 100 );
      
      	_loadProg.text = " Loaded: " + event.bytesLoaded + "\n"
                        + "  Total: " + event.bytesTotal + "\n"
                        + "Percent: " + percent;
						
		//trace(loadProg.text);
    }

	
    private function loadComplete(event:Event):void 
	{
		var loader:URLLoader = URLLoader(event.target);
			  
		// assign to output. The data property of the URLLoader is the file contents.
		parseData(loader.data);
    }
	
	private function parseData(loadedData:String):void 
	{
		var parsedData:Array = new Array();
		//var parsedMenu:Array = new Array();
		
		// Split the string into an array of words using a space as the delimiter.
		var lines:Array = loadedData.split("\n");
		var words:Array = new Array();
			
		// Loop through the array and do something with each word. 
		// In this example, just output the values.
		for ( var i:int = 0; i < lines.length; i++ ) {
			words = lines[i].split("\t");
			parsedData.push(words);
			//trace(parsedData[i][1]);
		}
		//gnurbwurk.parsedData = parsedData;
		_preloader.preloadComplete(parsedData);
		//gnurbwurk.main.load(parsedData);
		//gnurbwurk.main.make();
		//gnurbwurk.main.go();
		//gnurbwurk.main.makePatterns();
	}
  
  }//end class
}//end pkg
package metaswarm.build {
    import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.Shape;
	import flash.display.Sprite;
	import flash.events.Event;
	import flash.events.KeyboardEvent;
	import flash.events.MouseEvent;
	import flash.ui.Keyboard;
	import flash.net.*;
	import flash.utils.*;

    public class Preloader extends Sprite
    {
		private var _dataLoader:DataLoader;
		//var main:Main;
		private var _builder:Builder;
		
        public function Preloader(_builder:Builder):void{
			this._builder = _builder;
			this._dataLoader = new DataLoader(this);
			init();
		}
		
		//loads external data
		private function init():void{
			_dataLoader.preload();
		}
		
		public function preloadComplete(parsedData:Array):void{
			//trace("gw.preloadComplete");
			_builder.load(parsedData);
			_builder.make();
			_builder.go();
		}
		
    }//end class
}//end pkg
package metaswarm.control {
	import flash.display.*;
	import metaswarm.ui.hoverlabel.HoverLabel;
	import metaswarm.swarm.Swarm;
	import metaswarm.ui.Ui;
	import metaswarm.ui.UiState;
	
	public class Controller extends Sprite{
		
		private var _uiState:UiState;
		
		public function Controller(main:Ui){
			_uiState = main.uiState;
			
			init();
		}	
		private function init():void{
			//
		}
		
		//delegated methods**************************************************
		public function onEnterFrame():void{
			_uiState.onEnterFrame();
		}
		public function onRightKey():void{
			_uiState.onRightKey();
		}
		public function onLeftKey():void{
			_uiState.onLeftKey();
		}
		public function onUpKey():void{
			_uiState.onUpKey();
		}
		public function onDownKey():void{
			_uiState.onDownKey();
		}
		public function onSpaceKey():void{
			_uiState.onSpaceKey();
		}
		public function onKey1():void{
			_uiState.onKey1();
		}
		public function onKey2():void{
			_uiState.onKey2();
		}
		public function onKey3():void{
			_uiState.onKey3();
		}
		public function onKey4():void{
			_uiState.onKey4();
		}
		public function onKey5():void{
			//swarm.showUniqueTags();
		}
		public function onCtrlClick(node:Node, button:Object):void
		{
			_uiState.onCtrlClick(node, button);
		}
		public function onShftClick(node:Node, button:Object):void
		{
			_uiState.onShftClick(node, button);
		}
		public function onAltClick(node:Node, button:Object):void
		{
			//can't use alt b/c window uses it to focus toolbar
		}
		public function onCtrlShftClick(node:Node, button:Object):void
		{
			_uiState.onCtrlShftClick(node, button);
		}
		public function onMouseClick(node:Node, button:Object):void
		{
			_uiState.onMouseClick(node, button);
		}
		
		//public function onDataBoxClick(node:Node, button:Object):void{}
		public function onMouseDown(node:Node, button:Object):void
		{
			_uiState.onMouseDown(node, button);
		}
		public function onMouseUp(node:Node):void{
			_uiState.onMouseUp(node);
		}
		
		//over
		public function onMouseOver(node:Node, button:Object):void{
			_uiState.onMouseOver(node, button);
		}
		public function onCtrlOver(node:Node, button:Object):void{
			_uiState.onCtrlOver(node, button);
		}
		public function onShftOver(node:Node, button:Object):void{
			_uiState.onShftOver(node, button);
		}
		public function onCtrlShftOver(node:Node, button:Object):void{
			_uiState.onCtrlShftOver(node, button);
		}
		
		//out
		public function onMouseOut(node:Node):void{
			_uiState.onMouseOut(node);
		}
		public function onCtrlOut():void{
			_uiState.onCtrlOut();
		}
		public function onShftOut():void{
			_uiState.onShftOut();
		}
		public function onCtrlShftOut():void{
			//
		}
		

	}//end class
}//end pkg
package metaswarm.control {
    import flash.display.*;
	import flash.events.*;
	import flash.ui.Keyboard;
	import flash.net.*;
	import flash.utils.*;
	import flash.text.*;

	//import fl.controls.Label;

    public class Router extends Sprite
    {
		private var _controller:Controller; 
		//var dropped:Subset;
		//var picked:Subset;
		//var idle:Subset;
		
		//these should be scoped to methods
		private var _ctrlPressed:Boolean;
		private var _shftPressed:Boolean;
		private var _altPressed:Boolean;
		private var _mousedOver:Boolean;
		
		private var _focusedNode:Node;
		private var _focusedButton:Object;
		
        public function Router(controller:Controller):void
		{
			this._controller = controller; 
			
			_ctrlPressed = false;
			_shftPressed = false;
			_altPressed = false;
			_mousedOver = false;
			
			_focusedNode = new Node();
			_focusedButton = new Object();

			init();
		}
		private function init():void{ 
			//can't access this.stage until main is added to stage
			//addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);
		}
		
		//delegated methods **********************************************************
		public function onEnterFrame(event:Event):void{
			_controller.onEnterFrame();
			//cmdTag.x = mouseX;
			//cmdTag.y = mouseY;
		}
		
		public function onkeyDown(event:KeyboardEvent):void
		{
			if (event.keyCode == Keyboard.RIGHT){
				_controller.onRightKey();
			}else if (event.keyCode == Keyboard.LEFT){
				_controller.onLeftKey();
			}else if (event.keyCode == Keyboard.UP){
				_controller.onUpKey();
			}else if (event.keyCode == Keyboard.DOWN){
				_controller.onDownKey();
			}else if (event.keyCode == Keyboard.SPACE){
				_controller.onSpaceKey();
			}else if (event.keyCode == 49){
				trace("pressed 1");
				_controller.onKey1();
			}else if (event.keyCode == 50){
				trace("pressed 2");
				_controller.onKey2();
			}else if (event.keyCode == 51){
				trace("pressed 3");
				_controller.onKey3();
			}else if (event.keyCode == 52){
				trace("pressed 4");
				_controller.onKey4();
			}else if (event.keyCode == 53){
				trace("pressed 5");
				_controller.onKey5();
			}else if (event.ctrlKey == true || event.shiftKey == true){ 
			
				_ctrlPressed = event.ctrlKey;
				_shftPressed = event.shiftKey;
				
				if(_mousedOver){
					//just clear for now
					_controller.onShftOut();
						
					if(!_shftPressed && _ctrlPressed){
						_controller.onCtrlOver(_focusedNode, _focusedButton);
					}else if(_shftPressed && !_ctrlPressed){
						_controller.onShftOver(_focusedNode, _focusedButton);
					}else if(_shftPressed && _ctrlPressed){
						_controller.onCtrlShftOver(_focusedNode, _focusedButton);
					}else{
						//trace("neither ctrl nor shift was pressed and yet here we are");
					}
				}
			}else{
				//trace("you pressed an invalid key: " + event.keyCode);
			}
		}
		
		public function onkeyUp(event:KeyboardEvent):void
		{
			//reset ctrl and shft key states
			_ctrlPressed = event.ctrlKey;
			_shftPressed = event.shiftKey;
			
			//retest for focus conditions
			if(_mousedOver){

				//just clear for now
				_controller.onShftOut();
				
				if(!_shftPressed && _ctrlPressed){
					_controller.onCtrlOver(_focusedNode, _focusedButton);
				}else if(_shftPressed && !_ctrlPressed){
					_controller.onShftOver(_focusedNode, _focusedButton);
				}else if(_shftPressed && _ctrlPressed){
					_controller.onCtrlShftOver(_focusedNode, _focusedButton);
				}else{
					//trace("neither ctrl nor shift was pressed and yet here we are");
					_controller.onMouseOver(_focusedNode, _focusedButton);
				}
			}
		}
		
		//maybe get rid of this since it competes with mouseUp
		public function onMouseClick(event:MouseEvent):void{
			//trace(getQualifiedClassName(event.target));
			var grandparentClass:String = getQualifiedClassName(event.target.parent.parent);
			
			if(grandparentClass == "Node"){
				if(_ctrlPressed && _shftPressed){
					_controller.onCtrlShftClick(event.target.parent.parent, event.target);
				}else if(_ctrlPressed == true){
					_controller.onCtrlClick(event.target.parent.parent, event.target);
				}else if(_shftPressed == true){
					_controller.onShftClick(event.target.parent.parent, event.target);
				}else{
					_controller.onMouseClick(event.target.parent.parent, event.target);
				}
			}else{
				//trace("uh oh, grandparent is not a Node but a: " + grandparentClass);
			}
		}
		
		public function onMouseDown(event:MouseEvent):void
		{
			//var parentClass:String = getQualifiedClassName(event.target.parent);
			var grandparentClass:String = getQualifiedClassName(event.target.parent.parent);
			
			if(!_ctrlPressed && !_shftPressed && !_altPressed && grandparentClass == "Node"){
				_controller.onMouseDown(event.target.parent.parent, event.target);
			}else{
				//break if ctrl, shft, or alt is pressed
				//trace("don't drag");
			}
		}
		
		public function onMouseUp(event:MouseEvent):void
		{
			//var parentClass:String = getQualifiedClassName(event.target.parent);
			var grandparentClass:String = getQualifiedClassName(event.target.parent.parent);
			
			if(!_ctrlPressed && !_shftPressed && !_altPressed && grandparentClass == "Node"){
				_controller.onMouseUp(event.target.parent.parent);
			}else{
				//break if ctrl, shft, or alt is pressed
				//trace("don't drag");
			}
		}
		
		public function onMouseOver(event:MouseEvent):void
		{
			var grandparentClass:String = getQualifiedClassName(event.target.parent.parent);
			
			if(grandparentClass == "Node"){
				_mousedOver = true;
				_focusedNode = event.target.parent.parent;
				_focusedButton = event.target;
				if(!_ctrlPressed && !_shftPressed){
					_controller.onMouseOver(event.target.parent.parent, event.target);
				}else if(_ctrlPressed && !_shftPressed){
					_controller.onCtrlOver(event.target.parent.parent, event.target);
				}else if(!_ctrlPressed && _shftPressed){
					_controller.onShftOver(event.target.parent.parent, event.target);
				}else if(_ctrlPressed && _shftPressed){
					_controller.onCtrlShftOver(event.target.parent.parent, event.target);
				}
			}else{
				//trace("uh oh, grandparent is not a Node but a: " + grandparentClass);
			}
		}
		
		public function onMouseOut(event:MouseEvent):void
		{
			var grandparentClass:String = getQualifiedClassName(event.target.parent.parent);
			
			if(grandparentClass == "Node"){
				_mousedOver = false;
				//just clear for now
				_controller.onShftOut();
				_controller.onMouseOut(event.target.parent.parent);
			}else{
				//trace("uh oh, grandparent is not a Node but a: " + grandparentClass);
			}
		}

    }//end class
}//end pkg
package metaswarm.node     {
  import flash.display.*;
  import flash.text.*;
  import flash.events.*
  import flash.net.*;
  
  public class NodeLoader extends Sprite {
	    
	private var node:Node;
	
    public function NodeLoader(node:Node) 
	{
		this.node = node;
		//this.loadProg = new TextField();
		
		init();
    }
	private function init():void{
		//
	}
    
	public function load(dat:Array):void{
		//trace("nodeLoader load")
		node.dat = dat;
		node.dot.load();
		node.tag.load(dat);
		node.icon.load();
		//node.tag.load(node.dat);
		node.dataBox.load(dat);
		//node.thumb.load(node.dat[0] + node.dat[1]);
	}
	public function make():void{
		//trace("nodeLoader make")
		node.dot.make();
		node.tag.make();
		node.icon.make();
		node.dataBox.make();
		//node.thumb.make();
	}
	public function go():void{
		//nodes are initially idle
		//node.nodeState = node.idle;
		//node.addChild(node.thumb);
		node.addChild(node.dot);
		node.addChild(node.icon);
		node.addChild(node.tag);
		node.addChild(node.dataBox);
		//node.addChild(node.thumb); //just added this so I can remove bitmap loader from display list
	}
	
  }//end class
}//end pkg
package metaswarm.node     {
	
	//fsm interface
	public interface NodeState{ //<---------------------- public breaks program
		
		//internal interface methods
		//function filter():void;
		function select():void;	
		function deSelect():void;
		function toggleSelect():void;
		function drag():void;
		function drop():void;
		//function dropThumb():void;
		function popout():void;
		function popin():void;
		function close():void;
		function setTarget(tgx:Number,
						   tgy:Number):void;
		function rePosition():void;
		function reSize():void;
		function startFocus():void;
		function stopFocus():void;
		function startHover():void;
		function stopHover():void;
		//function incrTag():void;
		//function decrTag():void;
	}
}
package metaswarm.node.components   {
	import flash.display.DisplayObject;
	import flash.display.Graphics;
	import flash.display.Shape;
	import flash.display.Sprite;
	
	public class Particle extends Sprite{
		
		//public bc used in subclass plot functions
		//public static const DEF_CLR:Color 	= #000000;
		//public static const FOC_CLR:Color 	= #FF0000;
		private static const EASE:Number 	= .25;
		private static const SNAP:Number 	= 1;
		
		//Target Coordinates
		internal var tgx:Number;
		internal var tgy:Number;
		
		//Previous Coordinates
		public var px:Number;
		public var py:Number;
		
		//distance to target
		private var dx:Number;
		private var dy:Number;
		
		//velocity
		private var vx:Number;
		private var vy:Number;
		
		//atTarget:Boolean; unnec. used expression instead		
		//hidden:Boolean; use inherited prop visible instead
		//infocus:Boolean; not needed because mouse events
		//are object oriented. that is they test for focus
		//internally
		
		//x
		//y
		//visible : Boolean 
			
		//still unclear about constructors, see pg 180 of FofEd anim.	
		public function Particle(tgx:Number=0,
								 tgy:Number=0,
								 dx:Number=0,
								 dy:Number=0,
								 vx:Number=0,
								 vy:Number=0):void
		{
			this.x = 0;
			this.y = 0;
			this.tgx = tgx;
			this.tgy = tgy;
			this.dx = dx;
			this.dy = dy;
			this.vx = vx;
			this.vy = vy;
			this.px = 0;
			this.py = 0;
			//init();
		}	
		
		/*public function init():void {
			//nothing for now
		}*/
		
		public function isVisible():Boolean { 
			return this.visible; 
		}
		
		//use move(x,y) instead
		/*public function position(xNew:Number, yNew:Number):void
		{
			this.x = xNew;
			this.y = yNew;
		}*/
		
		public function goToTarget():void {
			//trace("x,y before: " + dx + " " + dy);
			//trace("tgs before: " + tgx + " " + tgy);
			dx = tgx - x;
			dy = tgy - y;
			if(Math.sqrt(dx*dx + dy*dy) < SNAP){
				x = tgx;
				y = tgy;
				//removeEventListener(Event.Enter_FRAME, onEnterFrame);
			}else{
				vx = dx * EASE;
				vy = dy * EASE;
				x += vx;
				y += vy;
			}
			//trace("after: " + dx + " " + dy);
			//trace("tgs after: " + tgx + " " + tgy);
		}
		
		public function snapToTarget():void{ //<-------------wtf
			x = tgx;
			y = tgy;
		}
				
		public function setTarget(a:Number, b:Number):void {//<-------------wtf
			tgx = a;
			tgy = b;
		}
		
		public function setPrev(a:Number, b:Number):void {//<-------------wtf
			px = a;
			py = b;
		}
		
		//getFocus():Interactive Object
		//hitTestPoint(x:Number, y:Number, shapeFlag:Boolean = false):Boolean 
		//startDrag()
		//stopDrag()
	}
}
package metaswarm.node.components.databox   {
	import flash.display.*;
	import flash.text.*;
	
	public class ButtonDisplayState extends Sprite {
		
		private var typeOfButton:String;
		private var bgColor:uint;
		private var lineColor:uint;
		private var size:uint;
	
		public function ButtonDisplayState(typeOfButton:String, lineColor:uint, bgColor:uint, size:uint) {
			this.typeOfButton = typeOfButton;
			this.bgColor = bgColor;
			this.lineColor = lineColor;
			this.size = size;
			draw();
		}
	
		private function draw():void {
			graphics.beginFill(bgColor);
			graphics.drawRect(0, 0, size, size);
			graphics.endFill();
			graphics.lineStyle(0, lineColor);
			//graphics.beginFill(lineColor);
			
			//. . . . .
			//. a . b .
			//. . . . .
			//. c . d .
			//. . . . .
			var ax:Number = size*(1/4);
			var ay:Number = size*(1/4);
			var bx:Number = size*(3/4);
			var by:Number = size*(1/4);
			var cx:Number = size*(1/4);
			var cy:Number = size*(3/4);
			var dx:Number = size*(3/4);
			var dy:Number = size*(3/4);
			
			
			switch (typeOfButton) {
				case "close"://x
					//trace(0);
					graphics.moveTo(ax, ay);
					graphics.lineTo(dx, dy);
					graphics.moveTo(bx, by);
					graphics.lineTo(cx, cy);
					break;
				case "popout"://>
					//trace(1);
					graphics.moveTo(ax, ay);
					graphics.lineTo(dx, dy);
					graphics.moveTo(bx, by);
					graphics.lineTo(dx, dy);
					graphics.lineTo(cx, cy);
					break;
				case "popin"://<
					//trace(2);
					graphics.moveTo(ax, ay);
					graphics.lineTo(dx, dy);
					graphics.moveTo(bx, by);
					graphics.lineTo(ax, ay);
					graphics.lineTo(cx, cy);
					break;
				default:
					trace("Not a valid type of button");
			}
			
			//graphics.endFill();
			
			/*var label:TextField = new TextField();
			var fmt:TextFormat = new TextFormat(txt, size/2, 0xCCCCCC);
			//label.x = dbx.closeButton.x;
			//label.y = dbx.closeButton.y;
			label.autoSize = TextFieldAutoSize.LEFT;
			//label.width = size;
			//label.height = size;
			label.setTextFormat(fmt);
			label.text = txt;
			addChild(label);
			label.mouseEnabled = false;*/
		}
	}
}
package metaswarm.node.components.databox   {
	import flash.display.*;
	import flash.text.*;
	
	public class CustomSimpleButton extends SimpleButton {
		/*private var upColor:uint   = 0xFFCC00;
		private var overColor:uint = 0xCCFF00;
		private var downColor:uint = 0x00CCFF;
		private var black:uint = 0x231F20;*/
		
		private static const BLACK:uint = 0x231F20;
		private static const WHITE:uint = 0xFFFFFF;
		private static const BRIGHTRED:uint = 0xFF3333;
		private static const BRIGHTBLUE:uint = 0x66CDFF;
		
		public var size:uint;
		public var type:String;
	
		public function CustomSimpleButton(type:String) {
			this.size = 15;
			this.type = type;
			downState      = new ButtonDisplayState(type, BRIGHTBLUE, BLACK, size);
			overState      = new ButtonDisplayState(type, BRIGHTRED, BLACK, size);
			upState        = new ButtonDisplayState(type, WHITE, BLACK, size);
			hitTestState   = new ButtonDisplayState(type, WHITE, BLACK, size);
			hitTestState.x = -(size / 4);
			hitTestState.y = hitTestState.x;
			useHandCursor  = true;
		}
		
		public function make():void {
			/*downState      = new ButtonDisplayState(downColor, size, txt);
			overState      = new ButtonDisplayState(overColor, size, txt);
			upState        = new ButtonDisplayState(upColor, size, txt);
			hitTestState   = new ButtonDisplayState(upColor, size, txt);
			hitTestState.x = -(size / 4);
			hitTestState.y = hitTestState.x;
			useHandCursor  = true;*/
		}
	}
}


package metaswarm.node.components.databox   {
	import flash.display.*;
	import flash.text.*;
	import flash.events.*;
	import flash.utils.*;
	import metaswarm.node.components.Particle;
	
	public class DataBox extends Particle{
		
		//need an idea for select and filter functions
		//e.g. select matching text with id eq to this.
		//this is id of array element no textBox
		//var id:uint;
	
		public var dat:Array;
		
		public var t:TextField = new TextField();
		
		public var closeButton:CustomSimpleButton;
		public var popoutButton:CustomSimpleButton;
		public var popinButton:CustomSimpleButton;
		//var loadExtButton:CustomSimpleButton;
		
		public var dataBoxMaker:DataBoxMaker;
		
		public function DataBox():void{
			dataBoxMaker = new DataBoxMaker(this);
			init();
		}
		public function init():void {
			visible = false;
			focusRect = true;
			tabEnabled = true;
			
			//addEventListener(MouseEvent.CLICK, onMouseClick);
		}
		public function load(dat:Array):void{
			this.dat = dat;
		}
		public function make():void {
			dataBoxMaker.make();
		}
		
		private function onMouseClick(event:MouseEvent):void{
			//trace(getQualifiedClassName(event.target));
			
			/*if(getQualifiedClassName(event.target) == "::CustomSimpleButton"){
				switch (event.target.type) {
					case CLOSE:
						trace("close");
						break;
					case POPOUT:
						trace("popout");
						parent.thumb.load(dat[0] + dat[1]);
						parent.thumb.make();
						parent.thumb.x = this.width;
						parent.thumb.y = this.y;
						parent.addChild(parent.thumb);
						break;
					case POPIN:
						trace("popin");
						break;
					default:
						trace("Not a valid type of button");
				}
			}*/
		}
		
	}//end class
}//end pkg
package metaswarm.node.components.databox   {
	import flash.display.*;
	import flash.text.*;
	
	class DataBoxButton extends SimpleButton {
		/*private var upColor:uint   = 0xFFCC00;
		private var overColor:uint = 0xCCFF00;
		private var downColor:uint = 0x00CCFF;
		private var black:uint = 0x231F20;*/
		
		private static const BLACK:uint = 0x231F20;
		private static const WHITE:uint = 0xFFFFFF;
		private static const BRIGHTRED:uint = 0xFF3333;
		private static const BRIGHTBLUE:uint = 0x66CDFF;
		
		var size:uint;
		var type:String;
	
		public function DataBoxButton(type:String) {
			this.size = 15;
			this.type = type;
			downState      = new DataBoxButtonState(type, BRIGHTBLUE, BLACK, size);
			overState      = new DataBoxButtonState(type, BRIGHTRED, BLACK, size);
			upState        = new DataBoxButtonState(type, WHITE, BLACK, size);
			hitTestState   = new DataBoxButtonState(type, WHITE, BLACK, size);
			hitTestState.x = -(size / 4);
			hitTestState.y = hitTestState.x;
			useHandCursor  = true;
		}
		
		public function make() {
			/*downState      = new ButtonDisplayState(downColor, size, txt);
			overState      = new ButtonDisplayState(overColor, size, txt);
			upState        = new ButtonDisplayState(upColor, size, txt);
			hitTestState   = new ButtonDisplayState(upColor, size, txt);
			hitTestState.x = -(size / 4);
			hitTestState.y = hitTestState.x;
			useHandCursor  = true;*/
		}
	}
}


package metaswarm.node.components.databox   {
	import flash.display.*;
	import flash.text.*;
	
	class DataBoxButtonState extends Sprite {
		private var typeOfButton:String;
		private var bgColor:uint;
		private var lineColor:uint;
		private var size:uint;
	
		public function DataBoxButtonState(typeOfButton:String, lineColor:uint, bgColor:uint, size:uint) {
			this.typeOfButton = typeOfButton;
			this.bgColor = bgColor;
			this.lineColor = lineColor;
			this.size = size;
			draw();
		}
	
		private function draw():void {
			graphics.beginFill(bgColor);
			graphics.drawRect(0, 0, size, size);
			graphics.endFill();
			graphics.lineStyle(0, lineColor);
			//graphics.beginFill(lineColor);
			
			//. . . . .
			//. a . b .
			//. . . . .
			//. c . d .
			//. . . . .
			var ax:Number = size*(1/4);
			var ay:Number = size*(1/4);
			var bx:Number = size*(3/4);
			var by:Number = size*(1/4);
			var cx:Number = size*(1/4);
			var cy:Number = size*(3/4);
			var dx:Number = size*(3/4);
			var dy:Number = size*(3/4);
			
			
			switch (typeOfButton) {
				case "close"://x
					//trace(0);
					graphics.moveTo(ax, ay);
					graphics.lineTo(dx, dy);
					graphics.moveTo(bx, by);
					graphics.lineTo(cx, cy);
					break;
				case "popout"://>
					//trace(1);
					graphics.moveTo(ax, ay);
					graphics.lineTo(dx, dy);
					graphics.moveTo(bx, by);
					graphics.lineTo(dx, dy);
					graphics.lineTo(cx, cy);
					break;
				case "popin"://<
					//trace(2);
					graphics.moveTo(ax, ay);
					graphics.lineTo(dx, dy);
					graphics.moveTo(bx, by);
					graphics.lineTo(ax, ay);
					graphics.lineTo(cx, cy);
					break;
				default:
					trace("Not a valid type of button");
			}
			
			//graphics.endFill();
			
			/*var label:TextField = new TextField();
			var fmt:TextFormat = new TextFormat(txt, size/2, 0xCCCCCC);
			//label.x = dbx.closeButton.x;
			//label.y = dbx.closeButton.y;
			label.autoSize = TextFieldAutoSize.LEFT;
			//label.width = size;
			//label.height = size;
			label.setTextFormat(fmt);
			label.text = txt;
			addChild(label);
			label.mouseEnabled = false;*/
		}
	}
}
package metaswarm.node.components.databox   {
	import flash.display.*;
	import flash.text.*;
	
	public class DataBoxMaker extends Sprite{
		
		private static const CLOSE:String = "closeDataBox";
		private static const POPOUT:String = "popout";
		private static const POPIN:String = "popin";
		
		public var dbx:DataBox;
		
		public function DataBoxMaker(dataBox:DataBox):void{
			this.dbx = dataBox;
			init();
		}
		public function init():void {
			//
		}
		public function make():void {
			makeTextField();
			//makeButtons();
		}
		
		private function makeTextField():void {
			/*h1 = new TextField();
			h2 = new TextField();
			h3 = new TextField();
			l = new TextField();*/
			//var t:TextField = new TextField(); 

			var h1Fmt:TextFormat = new TextFormat("Technic", 18, 0x333333);
			//var h2Fmt:TextFormat = new TextFormat();
			var h3Fmt:TextFormat = new TextFormat("Technic", 14, 0x06c);
			var lFmt:TextFormat = new TextFormat("Technic", 8, 0x333333);
			
			/*h1Fmt.TextFormat(font:String = null, 
					   size:Object = null, 
					   color:Object = null, 
					   bold:Object = null, 
					   italic:Object = null, 
					   underline:Object = null, 
					   url:String = null, 
					   target:String = null, 
					   align:String = null, 
					   leftMargin:Object = null, 
					   rightMargin:Object = null, 
					   indent:Object = null, 
					   leading:Object = null);*/
			
			//alwaysShowSelection : Boolean 
			 
			
			//dbx.t.autoSize = TextFieldAutoSize.LEFT;
			dbx.t.height = 100;
			dbx.t.width = 100;
			//dbx.t.background = true;
			//dbx.t.backgroundColor = 0x231F20; 
			dbx.t.alpha = 50;
			//dbx.t.border = true; 
			//dbx.t.borderColor = 0x000000; 
			//t.height = 
			//t.width = 
			dbx.t.mouseEnabled  = false;
			//t.mouseWheelEnabled = true; 
			//t.multiline = true; 
			dbx.t.wordWrap = true;
			
			//t.numLines [read-only]  
			//t.length [read-only]
			//t.scrollH : int 
			//t.scrollV : int 
			//t.selectable = true; 
			//t.tabEnabled = true;  
			//t.thickness : Number
			/*//t.width = 
			//t.height =
			t.background = true;
			t.backgroundColor = 0xCCCCCC; //light gray
			t.border = true;
			t.borderColor = 0x333333; //dark gray
			t.autoSize = TextFieldAutoSize.LEFT;
			//addChild(this);*/
			dbx.t.text = "";
			
			var c0:uint = 0;
			var c1:uint = c0 + dbx.dat[0].length + dbx.dat[1].length +1;
			var c2:uint = c1 + dbx.dat[2].length + 1;
			var c3:uint = c2 + 10;
			
			dbx.t.appendText(dbx.dat[0] + dbx.dat[1] + '\n');
			dbx.t.appendText(dbx.dat[2] + '\n');
			dbx.t.appendText("__________" + '\n');
			//t.text += dat[0] + dat[1] + '\n';
			//t.text += dat[2] + '\n';
			//t.text += "__________" + '\n';

			for(var i:uint=3; i<dbx.dat.length; i++){
				dbx.t.appendText(dbx.dat[i] + ", ");
				//t.text += dat[i] + ", ";
			}
			
			dbx.t.setTextFormat(h1Fmt, c0, c1);
			dbx.t.setTextFormat(h3Fmt, c1, c2);
			dbx.t.setTextFormat(h3Fmt, c2, c3);
			dbx.t.setTextFormat(lFmt, c3, dbx.t.text.length);
			
			dbx.t.selectable = false;
			dbx.t.mouseEnabled = false;
			//this.id = 0;
			dbx.addChild(dbx.t);
			//initTag();
		}
		
		private function makeButtons():void {
			
			dbx.closeButton = new CustomSimpleButton(CLOSE);
			dbx.popoutButton = new CustomSimpleButton(POPOUT);
			dbx.popinButton = new CustomSimpleButton(POPIN);
			//dbx.loadExtButton:CustomSimpleButton = new CustomSimpleButton("e");
		
			//var myButton:Button = new Button();
			//dbx.close.label = "x";
			//dbx.close.emphasized = true;
			//dbx.close.width = 15;
			//close.move(20, 20);
			
			/*dbx.closeButton.make();
			dbx.popoutButton.make();
			dbx.popinButton.make();
			dbx.loadExtButton.make();*/
			
			dbx.closeButton.x = dbx.t.width-dbx.closeButton.width;
			//dbx.closeButton.y = dbx.t.height;
			
			dbx.popoutButton.x = dbx.t.width-dbx.popoutButton.width;
			dbx.popoutButton.y = dbx.t.height-15;
			
			dbx.popinButton.x = dbx.t.width-(15 * 2);
			dbx.popinButton.y = dbx.t.height-15;
			
			//dbx.loadExtButton.x = dbx.t.width-(15 * 3);
			//dbx.loadExtButton.y = dbx.t.height-15;
			
			
			dbx.addChild(dbx.closeButton);
			dbx.addChild(dbx.popoutButton);
			dbx.addChild(dbx.popinButton);
			//dbx.addChild(dbx.loadExtButton);
			
		}
	}
}
package metaswarm.node.components.dot    {
	import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.Shape;
	import flash.display.Sprite;
	import metaswarm.node.components.Particle;
	
	public class Dot extends Particle{
		
		public var dotMaker:DotMaker;
		public var dotButton:DotButton;
		
		public function Dot():void{
			dotMaker = new DotMaker(this);
			init();
		}
		public function init():void {
			//visible = true;
			//focusRect = true;
			//tabEnabled = true;
		}
		
		public function load():void{
			//
		}
		//might dep on load later, so leave here!
		public function make():void{
			dotMaker.make();
		}
		
	}
}
		
		
package metaswarm.node.components.dot    {
	import flash.display.*;
	
	public class DotButton extends SimpleButton{
		
		private static const BLACK:uint = 0x231F20;
		private static const WHITE:uint = 0xFFFFFF;
		private static const BRIGHTRED:uint = 0xFF3333;
		private static const BRIGHTBLUE:uint = 0x66CDFF;
		
		public var size:uint;
		public var type:String;
	
		public function DotButton() {
			this.size = 3;
			this.type = "dot";
			downState      = new DotButtonState(BRIGHTBLUE, WHITE, size);
			overState      = new DotButtonState(BRIGHTRED, WHITE, size);
			upState        = new DotButtonState(BLACK, WHITE, size);
			hitTestState   = new DotButtonState(BLACK, WHITE, size); //change to overstate
			hitTestState.x = -(size / 4);
			hitTestState.y = hitTestState.x;
			useHandCursor  = true;
		}
		
		public function forceOver():void{
			upState = overState;
		}
		
		public function restoreOver():void{
			upState = hitTestState;
		}
		
	}
}
package metaswarm.node.components.dot    {
	import flash.display.*;
	import flash.text.*;
	
	//should this extend shape instead????
	public class DotButtonState extends Sprite {
		//private var typeOfButton:uint;
		private var bgColor:uint;
		private var lineColor:uint;
		private var size:uint;
	
		public function DotButtonState(lineColor:uint, bgColor:uint, size:uint) {
			//this.typeOfButton = typeOfButton;
			this.bgColor = bgColor;
			this.lineColor = lineColor;
			this.size = size;
			draw();
		}
	
		private function draw():void {
			//trace("draw the dot button state");
			graphics.beginFill(bgColor);
			graphics.drawRect(-size, -size, size*2, size*2);
			graphics.endFill();
			
			graphics.lineStyle(0, lineColor);
			graphics.moveTo(x, y-size);
			graphics.lineTo(x, y+size);
			graphics.moveTo(x-size, y);
			graphics.lineTo(x+size, y);
		}
	}
}
package metaswarm.node.components.dot    {
	import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.Shape;
	import flash.display.Sprite;
	
	public class DotMaker extends Sprite{
		
		private var _dot:Dot;
		
		public function DotMaker(dot:Dot):void{
			_dot = dot;
			init();
		}
		public function init():void{
			//
		}
		public function make():void{
			_dot.dotButton = new DotButton();
			_dot.addChild(_dot.dotButton);
		}
	}
}
package metaswarm.node.components.icon   {
	import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.Shape;
	import flash.display.Sprite;
	import metaswarm.node.components.Particle;
	
	
	public class Icon extends Particle{
		
		private static const Z_EASE:Number 	= 1;
		private static const Z_SNAP:Number 	= 1;
		
		//Target zoom
		private var tgw:Number;
		
		//radial distance to zoom target
		private var dw:Number;
		
		//zoom velocity
		private var vw:Number;
		
		//should be a customSimpleButton not a maker
		public var iconMaker:IconMaker;
		public var iconButton:IconButton;
		
		public function Icon(tgw:Number=0,
							dw:Number=0,
							vw:Number=0):void
		{
			this.x = 0;
			this.y = 0;
			this.tgw = tgw;
			this.dw = dw;
			this.vw = vw;
			
			iconMaker = new IconMaker(this);
			
			init();
		}
		public function init():void {
			visible = false;
			focusRect = true;
			tabEnabled = true;
			doubleClickEnabled = true;
			//mouseEnabled = false;
		}
		
		public function load():void{
			//
		}
		//might depend on load later, so keep here
		//rather than put in init
		public function make():void{
			iconMaker.make();
		}
		
		public function scaleToTarget():void {
			dw = tgw - this.width;
			if(Math.abs(dw - Z_SNAP)<1){
				this.width = tgw;
				this.height = tgw;
				//removeEventListener(Event.Enter_FRAME, onEnterFrame);
			}else{
				vw = dw * Z_EASE;
				this.width += vw;
				this.height += vw;
			}
		}
				
		public function setTargetWidth(a:Number):void {
			tgw = a;
		}
	}
}
			
package metaswarm.node.components.icon   {
	import flash.display.*;
	
	public class IconButton extends SimpleButton{
		
		private static const BLACK:uint = 0x231F20;
		private static const WHITE:uint = 0xFFFFFF;
		private static const BRIGHTRED:uint = 0xFF3333;
		private static const BRIGHTBLUE:uint = 0x66CDFF;
		
		public var size:uint;
		public var type:String;
	
		public function IconButton() {
			this.size = 3;
			this.type = "icon";
			downState      = new IconButtonState(BRIGHTBLUE, BLACK, size);
			overState      = new IconButtonState(BRIGHTRED, BLACK, size);
			upState        = new IconButtonState(WHITE, BLACK, size);
			hitTestState   = new IconButtonState(WHITE, BLACK, size);
			hitTestState.x = -(size / 4);
			hitTestState.y = hitTestState.x;
			useHandCursor  = true;
		}
		
		public function forceOver():void{
			upState = overState;
		}
		
		public function restoreOver():void{
			upState = hitTestState;
		}
		
		/*//should be draw()
		public function make():void {
			icon.graphics.beginFill(0x0000ff);
			icon.graphics.lineStyle(0);
			icon.graphics.drawRect(0, 0, 10, 10);
			icon.graphics.endFill();
		}*/
	}
}
package metaswarm.node.components.icon   {
	import flash.display.*;
	import flash.text.*;
	
	//should this extend shape instead????
	public class IconButtonState extends Sprite {
		//private var typeOfButton:uint;
		private var bgColor:uint;
		private var lineColor:uint;
		private var size:uint;
	
		public function IconButtonState(lineColor:uint, bgColor:uint, size:uint) {
			//this.typeOfButton = typeOfButton;
			this.bgColor = bgColor;
			this.lineColor = lineColor;
			this.size = size;
			draw();
		}
	
		private function draw():void {
			//trace("draw the icon button state");
			graphics.beginFill(bgColor);
			graphics.lineStyle(0, lineColor);
			//graphics.drawRect(0, 0, size, size);
			graphics.drawRect(-size, -size, size*2, size*2);
			graphics.endFill();
		}
	}
}
package metaswarm.node.components.icon {
	import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.Shape;
	import flash.display.Sprite;
	
	public class IconMaker extends Sprite{
		
		public var icon:Icon;
		
		public function IconMaker(icon:Icon):void{
			this.icon = icon;
			init();
		}
		public function init():void {
			//
		}
		public function make():void {
			//trace("make the icon button");
			icon.iconButton = new IconButton();
			icon.addChild(icon.iconButton);
		}
	}
}
package metaswarm.node.components.tag   {
	import flash.display.*;
	import flash.text.*;
	import metaswarm.node.components.Particle;
	
	public class Tag extends Particle{
		
		//add formatting constants here
		public var tagMaker:TagMaker;
		public var tagButton:TagButton;
		//zoom velocity
		//private var val:String;
		public var t:TextField;
		//var fmt:TextFormat;
		public var uniqArr:Array = new Array();
		public var isUniq:Boolean = new Boolean();
		
		//need an idea for select and filter functions
		//e.g. select matching text with id eq to this.
		//this is id of array element no textBox
		public var id:uint;
		
		//cnt not nec, can just use array length
		//var cnt:uint;
		public var dat:Array;
		//var dat:Array = ["cherry", "orange", "soda", "pop"];
		
		public function Tag():void
		{
			t = new TextField();
			tagMaker = new TagMaker(this);
			//fmt = new TextFormat( );
			init();
		}
		public function init():void {
			visible = false;
			//focusRect = false;
			//tabEnabled = false;
			//tag.mouseEnabled = false;
		}
		
		public function load(dat:Array):void{
			this.dat = dat;
		}
		public function make():void{
			tagMaker.make();
		}
		
		public function incr():void{
			if(id < dat.length-1){
				id++;
			}else{
				id=0;
			}
			t.text = dat[id];
			isUniq = uniqArr[id];
			//t.text = String(this.tgx) + ", " + String(this.tgy);
		}
		
		public function decr():void{
			if(id > 0){
				id--;
			}else{
				id=dat.length-1;
			}
			t.text = dat[id];
			isUniq = uniqArr[id];
			//t.text = String(this.tgx) + ", " + String(this.tgy);
		}
		
		/*public function getDatAt(id):void{
			return dat[id];
		}*/
		
	}//end class
}//end pkg
package metaswarm.node.components.tag   {
	import flash.display.*;
	
	public class TagButton extends SimpleButton{
		
		private static const BLACK:uint = 0x231F20;
		private static const WHITE:uint = 0xFFFFFF;
		private static const BRIGHTRED:uint = 0xFF3333;
		private static const BRIGHTBLUE:uint = 0x66CDFF;
		
		public var size:uint;
		public var type:String;
	
		public function TagButton() {
			this.size = 5;
			this.type = "tag";
			downState      = new TagButtonState(BRIGHTBLUE, BLACK, size);
			overState      = new TagButtonState(BRIGHTRED, BLACK, size);
			upState        = new TagButtonState(WHITE, BLACK, size);
			hitTestState   = new TagButtonState(WHITE, BLACK, size);
			hitTestState.x = -(size / 4);
			hitTestState.y = hitTestState.x;
			useHandCursor  = true;
		}
		
		public function forceOver():void{
			upState = overState;
		}
		
		public function restoreOver():void{
			upState = hitTestState;
		}
		
		/*//should be draw()
		public function make():void {
			icon.graphics.beginFill(0x0000ff);
			icon.graphics.lineStyle(0);
			icon.graphics.drawRect(0, 0, 10, 10);
			icon.graphics.endFill();
		}*/
	}
}
package metaswarm.node.components.tag   {
	import flash.display.*;
	import flash.text.*;
	
	//should this extend shape instead????
	public class TagButtonState extends Sprite {
		//private var typeOfButton:uint;
		private var bgColor:uint;
		private var lineColor:uint;
		private var size:uint;
	
		public function TagButtonState(lineColor:uint, bgColor:uint, size:uint) {
			//this.typeOfButton = typeOfButton;
			this.bgColor = bgColor;
			this.lineColor = lineColor;
			this.size = size;
			//draw();
		}
	
		//need ref to tag, can't do this yet
		/*private function draw():void {
			//tag.tagButton = new TagButton();
			//tag.addChild(tag.tagButton);
			
			var fmt:TextFormat = new TextFormat( );
			
			fmt.font = "Arial";
			fmt.size = size;
			//tag.t.embedFonts = true;
			//tag.t.antiAliasType = AntiAliasType.ADVANCED;
			tag.t.text = "";
			tag.t.setTextFormat(fmt);
			tag.t.selectable = false;
			tag.t.mouseEnabled = false;
			tag.id = 0;
			
			tag.t.x += 5;
			tag.t.y -= 25;
			//t.width = 
			//t.height =
			tag.t.background = true
			tag.t.backgroundColor = bgColor; //light gray
			//tag.t.border = true;
			tag.t.borderColor = lineColor; //dark gray
			tag.t.autoSize = TextFieldAutoSize.LEFT;
			//addChild(this);
			
			tag.t.text = tag.dat[tag.id];
			
			tag.addChild(tag.t);
		}*/
		
	}
}
package metaswarm.node.components.tag   {
	import flash.display.*;
	import flash.text.*;
	
	public class TagMaker extends Sprite{
		
		private var tag:Tag;
		
		public function TagMaker(tag:Tag):void{
			this.tag = tag;
			init();
		}
		public function init():void {
			//
		}
		
		/*public function make():void {
			//trace("make the tag button");
			tag.tagButton = new TagButton();
			tag.addChild(tag.tagButton);
		}*/
		
		public function make():void {
			//tag.tagButton = new TagButton();
			//tag.addChild(tag.tagButton);
			
			var fmt:TextFormat = new TextFormat( );
			
			fmt.font = "Arial";
			fmt.size = 5;
			//tag.t.embedFonts = true;
			//tag.t.antiAliasType = AntiAliasType.ADVANCED;
			tag.t.text = "";
			tag.t.setTextFormat(fmt);
			tag.t.selectable = false;
			tag.t.mouseEnabled = false;
			tag.id = 0;
			
			tag.t.x += 5;
			tag.t.y -= 25;
			//t.width = 
			//t.height =
			tag.t.background = true
			tag.t.backgroundColor = 0xCCCCCC; //light gray
			tag.t.border = true;
			tag.t.borderColor = 0x333333; //dark gray
			tag.t.autoSize = TextFieldAutoSize.LEFT;
			//addChild(this);
			
			tag.t.text = tag.dat[tag.id];
			
			tag.addChild(tag.t);
		}
	}
}
package metaswarm.node.components.thumb   {
  import flash.display.*;
  import flash.text.*;
  import flash.events.*
  import flash.net.*;
  import flash.geom.Matrix;
  
  public class BitmapLoadr extends Sprite {
	  
	public var loadProg:TextField;
	public var thumb:Thumb;
	
	private var loader:Loader; // The bitmap loader
	//var parsedData:Array; 
    //var output:String;
	//private static const PATH:String = "../index.txt";
	
    public function BitmapLoadr(thumb:Thumb) {
		this.thumb = thumb;
		init();
    }
    private function init():void { 
		loader = new Loader();
		loadProg = new TextField();
      	//loadProg.width = stage.stageWidth;
      	//loadProg.height = stage.stageHeight;
      	thumb.addChild(loadProg); 
    }
	public function loadBmp(path:String):void {
		// Listen for the progress event to check download progress
      	loader.contentLoaderInfo.addEventListener(ProgressEvent.PROGRESS, handleProgress);
		// listen for load complete
		loader.contentLoaderInfo.addEventListener(Event.COMPLETE, onComplete);
		// Register to be notified when the bitmap has been initialized
		loader.contentLoaderInfo.addEventListener(Event.INIT, onInit);
		
		loader.load(new URLRequest("1.JPG"));
	}
		
	// Triggered when the bitmap has been loaded and initialized
	private function onInit(event:Event):void {
		//trace("onInit");
		var loadedBitmap:Bitmap = Bitmap(loader.content);
		
		var loadedBitmapData:BitmapData = loadedBitmap.bitmapData;
		
		// Set the amount by which to scale the bitmap
		var scaleFactor:Number = .5;
		
		/*//specify the height here for now <<<<<<<<<********************************************
		var newHeight:int = 100;
		
		// Calculate the new dimensions of the scaled bitmap
		scaleFactor = newHeight/loadedBitmapData.height;
		var newWidth:int = loadedBitmapData.width * scaleFactor;*/
		
		//specify the height here for now <<<<<<<<<********************************************
		var newWidth:int = 125;
		
		// Calculate the new dimensions of the scaled bitmap
		scaleFactor = newWidth/loadedBitmapData.width;
		var newHeight:int = loadedBitmapData.height * scaleFactor;
		
		// Create a new BitmapData object, sized to hold the scaled bitmap
		var scaledBitmapData:BitmapData = new BitmapData(newWidth, newHeight,
											loadedBitmapData.transparent);
		
		// Create a transformation matrix that will scale the bitmap
		var scaleMatrix:Matrix = new Matrix();
		scaleMatrix.scale(scaleFactor, scaleFactor);
		
		//loadedBitmapData.draw(loadedBitmap, new Matrix())
		// Draw the scaled bitmap into the new BitmapData object
		scaledBitmapData.draw(loadedBitmapData, scaleMatrix);
		
		// Replace the original BitmapData object with the
		// new, scaled BitmapData object
		//loadedBitmap.bitmapData = scaledBitmapData;
		
		// Create a new Bitmap using the BitmapData
    	// and display it.
    	//var newImage:Bitmap = new Bitmap(loadedBitmapData);
    	
		thumb.bmpButton.bmp.bitmapData = scaledBitmapData;
		//addChild(thumb.bmp);
		
		//thumb.bmp = loadedImage;
		thumb.bmpButton.addChild(thumb.bmpButton.bmp);
	}
	
	private function handleProgress(event:ProgressEvent):void {
      	// Calculate the percentage loaded
      	var percent:Number = Math.round(event.bytesLoaded 
                                      / event.bytesTotal * 100 );
      
      	loadProg.text = " Loaded: " + event.bytesLoaded + "\n"
                      + "  Total: " + event.bytesTotal + "\n"
                      + "Percent: " + percent;
						
		//trace(loadProg.text);
    }
	
	private function onComplete(event:Event):void {
		//done with loadProg so remove it
     	thumb.removeChild(loadProg);
    }
  
  }//end class
}//end pkg
package metaswarm.node.components.thumb   {
	import flash.display.*;
	import flash.text.*;
	
	public class BmpButton extends Sprite{
		
		public var type:String;
		
		public var bmp:Bitmap;
	
		public function BmpButton() {
			this.type = "bmp";
			
			bmp = new Bitmap();
		}
		
		public function make():void {
		}
	}
}
package metaswarm.node.components.thumb   {
	import flash.display.*;
	import flash.events.*;
    import flash.net.URLRequest;
	import flash.text.*;
	import metaswarm.node.components.Particle;
	
	public class Thumb extends Particle{
		
		public var path:String;
		
		public var ldr:BitmapLoadr;
		public var bmpButton:BmpButton;
		public var bmpLoaded:Boolean;
		public var thumbMaker:ThumbMaker;
		
		public var header:TextField = new TextField();
		public var footer:TextField = new TextField();
		
		public var closeButton:ThumbButton;
		public var popoutButton:ThumbButton;
		public var popinButton:ThumbButton;
		
		public function Thumb():void {
			ldr = new BitmapLoadr(this);
			bmpButton = new BmpButton();
			bmpLoaded = false;
			thumbMaker = new ThumbMaker(this);
			init();
		}
		public function init():void {
			//addChild(ldr); //no no no
			visible = false;
			//focusRect = true;
			//tabEnabled = true;
		}
		
		public function load(path:String):void{
			this.path = path;
			if(!bmpLoaded){
				ldr.loadBmp(path);
				bmpLoaded = true;
			}
		}
		public function make():void{
			thumbMaker.make();
		}
	}
}
package metaswarm.node.components.thumb   {
	import flash.display.*;
	import flash.text.*;
	
	public class ThumbButton extends SimpleButton {
		/*private var upColor:uint   = 0xFFCC00;
		private var overColor:uint = 0xCCFF00;
		private var downColor:uint = 0x00CCFF;
		private var black:uint = 0x231F20;*/
		
		private static const BLACK:uint = 0x231F20;
		private static const LIGHTGREY:uint = 0xfcfcfc;
		private static const WHITE:uint = 0xFFFFFF;
		private static const BRIGHTRED:uint = 0xFF3333;
		private static const BRIGHTBLUE:uint = 0x66CDFF;
		
		public var size:uint;
		public var type:String;
	
		public function ThumbButton(type:String) {
			this.size = 15;
			this.type = type;
			downState      = new ThumbButtonState(type, BRIGHTBLUE, BLACK, size);
			overState      = new ThumbButtonState(type, BRIGHTRED, BLACK, size);
			upState        = new ThumbButtonState(type, WHITE, BLACK, size);
			hitTestState   = new ThumbButtonState(type, WHITE, BLACK, size);
			hitTestState.x = -(size / 4);
			hitTestState.y = hitTestState.x;
			useHandCursor  = true;
		}
		
		public function make():void {
			//
		}
	}
}
package metaswarm.node.components.thumb   {
	import flash.display.*;
	import flash.text.*;
	
	public class ThumbButtonState extends Sprite {
		private var typeOfButton:String;
		private var bgColor:uint;
		private var lineColor:uint;
		private var size:uint;
	
		public function ThumbButtonState(typeOfButton:String, lineColor:uint, bgColor:uint, size:uint) {
			this.typeOfButton = typeOfButton;
			this.bgColor = bgColor;
			this.lineColor = lineColor;
			this.size = size;
			draw();
		}
	
		private function draw():void {
			graphics.beginFill(bgColor);
			graphics.drawRect(0, 0, size, size);
			graphics.endFill();
			graphics.lineStyle(1, lineColor);
			//graphics.beginFill(lineColor);
			
			//. . . . .
			//. a . b .
			//. . . . .
			//. c . d .
			//. . . . .
			var ax:Number = size*(1/4);
			var ay:Number = size*(1/4);
			var bx:Number = size*(3/4);
			var by:Number = size*(1/4);
			var cx:Number = size*(1/4);
			var cy:Number = size*(3/4);
			var dx:Number = size*(3/4);
			var dy:Number = size*(3/4);
			
			
			switch (typeOfButton) {
				case "closeThumb"://x
					//trace(0);
					graphics.moveTo(ax, ay);
					graphics.lineTo(dx, dy);
					graphics.moveTo(bx, by);
					graphics.lineTo(cx, cy);
					break;
				case "popout"://>
					//trace(1);
					graphics.moveTo(ax, ay);
					graphics.lineTo(dx, dy);
					graphics.moveTo(bx, by);
					graphics.lineTo(dx, dy);
					graphics.lineTo(cx, cy);
					break;
				case "popin"://<
					//trace(2);
					graphics.moveTo(ax, ay);
					graphics.lineTo(dx, dy);
					graphics.moveTo(bx, by);
					graphics.lineTo(ax, ay);
					graphics.lineTo(cx, cy);
					break;
				default:
					trace("Not a valid type of button");
			}
		}
	}
}
package metaswarm.node.components.thumb   {
	import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.Shape;
	import flash.display.Sprite;
	import flash.text.*;
	
	public class ThumbMaker extends Sprite{
		
		private static const CLOSETHUMB:String = "closeThumb";
		private static const POPOUT:String = "popout";
		private static const POPIN:String = "popin";
		
		private var thumb:Thumb;
		
		public function ThumbMaker(thumb:Thumb):void{
			this.thumb = thumb;
			init();
		}
		public function init():void {
			//
		}
		public function make():void {
			//
			makeHeader();
			//makeFooter();
			makeButtons();
			//thumb.bmp.y = thumb.header.height;
			/*thumb.closeButton = new ThumbButton(CLOSETHUMB);
			thumb.closeButton.x = thumb.width-thumb.closeButton.width;
			thumb.addChild(thumb.closeButton);*/
		}
		
		private function makeHeader():void {
			
			var fmt:TextFormat = new TextFormat("Technic", 12, 0x66CDFF);
			
			//thumb.header.height = 15;
			//thumb.header.width = 125;
			thumb.header.background = true;
			thumb.header.backgroundColor = 0x231F20; 
			//thumb.header.alpha = 50;
			//thumb.header.border = true; 
			//thumb.header.borderColor = 0x000000; 
		
			thumb.header.autoSize = TextFieldAutoSize.LEFT;
			//addChild(this);*/
			thumb.header.text = "123.jpg";
			
			thumb.header.setTextFormat(fmt);
			
			thumb.header.selectable = false;
			thumb.header.mouseEnabled = false;
			//this.id = 0;
			thumb.addChild(thumb.header);
			//initTag();
		}
		
		private function makeFooter():void {
			
			var fmt:TextFormat = new TextFormat("Technic", 10, 0x000000);
			
			thumb.footer.height = 15;
			thumb.footer.width = 125;
			thumb.footer.background = true;
			thumb.footer.backgroundColor = 0xffffff; 
		
			//thumb.header.autoSize = TextFieldAutoSize.LEFT;
			thumb.footer.text = "footer";
			
			thumb.footer.setTextFormat(fmt);
			
			thumb.footer.selectable = false;
			thumb.footer.mouseEnabled = false;
			//this.id = 0;
			
			//thumb.footer.x = 0;
			thumb.footer.y = thumb.footer.width;
			
			thumb.addChild(thumb.footer);
			//initTag();
		}
		
		private function makeButtons():void {
			
			//this should be in thumb class**************************
			thumb.closeButton = new ThumbButton(CLOSETHUMB);
			thumb.popoutButton = new ThumbButton(POPOUT);
			thumb.popinButton = new ThumbButton(POPIN);
			//thumb.loadExtButton:CustomSimpleButton = new CustomSimpleButton("e");
			
			var buttonSize:uint = thumb.closeButton.size;
			var thumbWidth:uint = 125;
		
			//var myButton:Button = new Button();
			//thumb.close.label = "x";
			//thumb.close.emphasized = true;
			//thumb.close.width = 15;
			//close.move(20, 20);
			
			/*thumb.closeButton.make();
			thumb.popoutButton.make();
			thumb.popinButton.make();
			thumb.loadExtButton.make();*/
			
			thumb.closeButton.x = thumbWidth - buttonSize;
			//thumb.closeButton.y = thumb.header.height;
			
			thumb.popoutButton.x = thumbWidth - buttonSize*2;
			//thumb.popoutButton.y = (thumb.header.height + thumb.bmp.height) - 15;
			//thumb.popoutButton.y = buttonSize;
			
			thumb.popinButton.x = thumbWidth - buttonSize*3;
			//thumb.popinButton.y = (thumb.header.height + thumb.bmp.height) - 15;
			//thumb.popinButton.y = buttonSize*2;
			
			//thumb.loadExtButton.x = thumb.header.width-(15 * 3);
			//thumb.loadExtButton.y = thumb.header.height-15;
			
			thumb.addChild(thumb.bmpButton);
			
			thumb.addChild(thumb.closeButton);
			thumb.addChild(thumb.popoutButton);
			thumb.addChild(thumb.popinButton);
			//thumb.addChild(thumb.loadExtButton);
			
			
			
		}
	}
}
package metaswarm.node.nodestates   {
	import metaswarm.node.NodeState;
	
	public class DraggingState implements NodeState{
		
		private var node:Node;
		
		public function DraggingState(node:Node)
		{
			//trace("construct DraggingState");
			this.node = node;
		}
		public function select():void{}
		
		public function deSelect():void{}
		
		public function toggleSelect():void{}
		
		public function drag():void{}
		
		public function drop():void{
			//trace("PickedState drag: goto dragging state");
			node.icon.visible = false;
			
			node.icon.stopDrag();
			node.thumb.stopDrag();
			
			node.thumb.x = node.icon.x;
			node.thumb.y = node.icon.y;
			node.thumb.setTarget(node.icon.x, node.icon.y);
			node.thumb.visible = true;
			
			//goto dropped state
			node.nodeState = node.dropped;
		}
		
		//public function dropThumb():void{}
		
		public function popout():void{}
		
		public function popin():void{}
		
		public function close():void{}
		
		public function setTarget(tgx:Number,
						   		  tgy:Number):void{
			//trace("DraggingState switch");
			//node.dot.setTarget(tgx, tgy);
		}
		
		public function rePosition():void{
			//trace("DraggingState rePosition");
			//node.dot.goToTarget();
			//node.thumb.x = node.icon.x;
			//node.thumb.y = node.icon.y;
			
			//dragging icon so snap dot to icon
			/*node.dot.x = node.dataBox.x;
			node.dot.y = node.dataBox.y;*/
			
			
		}
		
		public function reSize():void{
			//trace("DraggingState reSize");
			node.icon.scaleToTarget(); //???
		}
		
		public function startFocus():void{}
		
		public function stopFocus():void{}
		
		public function startHover():void{}
		
		public function stopHover():void{}
	}
}
package metaswarm.node.nodestates   {
	import metaswarm.node.NodeState;
	
	public class DroppedState implements NodeState{
		
		private var node:Node;
		
		public function DroppedState(node:Node)
		{
			//trace("construct DroppedState");
			this.node = node;
		}
		
		public function select():void{}
		public function deSelect():void{}
		public function toggleSelect():void{}
		
		public function drag():void{
			//trace("DroppedState drag: goto dragging state");
			
			//start dragging
			node.thumb.startDrag();
			
			//goto to dragging state
			node.nodeState = node.tdragging;
			node.prevState = node.dropped;
		}
		
		public function drop():void{}
		
		//public function dropThumb():void{}
		
		public function popout():void{
			//trace("DroppedState popout");
			
			//position dataBox next to thumb and show
			//node.dataBox.x = node.thumb.x + node.thumb.width;
			node.dataBox.x = node.thumb.x + 125;
			node.dataBox.y = node.thumb.y;
			node.dataBox.visible = true;
			
			//goto popped state
			node.nodeState = node.popped;
		}
		
		public function popin():void{}
		
		public function close():void{
			//trace("DroppedState close");
			
			//position dot at target
			node.dot.snapToTarget();
			
			//position icon at thumb position
			node.icon.x = node.thumb.x;
			node.icon.y = node.thumb.y;
			node.icon.setTarget(node.dot.x, node.dot.y);
			node.icon.visible = true;
			
			//hide thumb, but should i dispose of bitmap???
			node.thumb.visible = false; 
				
			//go back to idle
			node.nodeState = node.picked;
		}
		
		public function setTarget(tgx:Number,
						   		  tgy:Number):void{
			//trace("DroppedState switch");
			
			//preview mainstate needs this to tile
			//node.thumb.setTarget(tgx, tgy);
			
			//set dot target incase thumb is closed, 
			//dot it will get back in place in swarm
			node.dot.setTarget(tgx, tgy);
		}
		
		public function rePosition():void{
			//trace("DroppedState rePosition");
			
			//preview mainstate need this to tile 
			node.thumb.goToTarget();
		}
		
		public function startFocus():void{}
		public function stopFocus():void{}
		public function reSize():void{} //icon is not visible so don't bother
		public function startHover():void{} //change these names to hover or smth
		public function stopHover():void{}
		
	}
}
package metaswarm.node.nodestates   {
	import flash.geom.ColorTransform;
	import metaswarm.node.NodeState;
	
	public class IdleState implements NodeState{
		
		private var redTransform:ColorTransform;
		private var blkTransform:ColorTransform;
		
		private var node:Node;
		
		function IdleState(node:Node)
		{
			//trace("construct IdleState");
			this.node = node;
			
			redTransform = new ColorTransform( );
			redTransform.color = 0xFF0000;
			blkTransform = new ColorTransform( );
			blkTransform.color = 0xCCCCCC;
		}
		public function select():void{
			//trace("IdleState select:goto picked state");
			
			//node.dot.mouseEnabled = false;
			//stopFocus();
			
			node.dot.visible = false;
			
			//position icon at dot and make visible
			node.icon.x = node.dot.x;
			node.icon.y = node.dot.y;
			node.icon.setTargetWidth(6);
			node.icon.setTarget(node.dot.x, node.dot.y);
			node.icon.visible = true;
			
			//position tag at dot and make visible
			node.tag.x = node.dot.x;
			node.tag.y = node.dot.y;
			//node.tag.visible = true;
			
			//goto picked state
			node.nodeState = node.picked;
		}
		
		public function deSelect():void{}
		
		public function toggleSelect():void{
			select();
		}
		
		//public function filter():void{}
		
		public function drag():void{}
		
		public function drop():void{}
		
		//public function dropThumb():void{}
		
		public function popout():void{}
		
		public function popin():void{}
		
		public function close():void{}
		
		public function setTarget(tgx:Number,
						   		  tgy:Number):void{
			//trace("IdleState setTarget: " + tgx + ", " + tgy);
			node.dot.setTarget(tgx, tgy);
		}
		
		public function rePosition():void{
			//trace("IdleState rePosition");
			node.dot.goToTarget();
			
			node.tag.x = node.dot.x;
			node.tag.y = node.dot.y;
		}
		
		public function reSize():void{}
		
		public function startFocus():void{
			//trace("startFocus");
			//node.dot.transform.colorTransform = redTransform;
			
			/*private function doDrawCircle():void {
            var bounds:Shape = new Shape();
			var r:Rectangle = getRect(node.dot);
            //bounds.graphics.beginFill(bgColor);
			bounds.graphics.lineStyle(0, 0xFF3333); //red
			bounds.graphics.drawRect(r.x, r.y, r.width, r.height);
			//bounds.graphics.endFill();
			node.addChild(bounds);
        	}*/
			
			node.dot.dotButton.forceOver();
			node.tag.t.borderColor = 0xFF0000;
		
			node.tag.x = node.dot.x;
			node.tag.y = node.dot.y;
			//node.tag.visible = true;
		}
		public function stopFocus():void{
			//trace("stopFocus");
			//node.dot.transform.colorTransform = blkTransform;
			//node.tag.visible = false;
			
			node.dot.dotButton.restoreOver();
			node.tag.t.borderColor = 0xCCCCCC;
		}
		
		public function startHover():void{}
		
		public function stopHover():void{}
		
	}
}
package metaswarm.node.nodestates   {
	import flash.events.TimerEvent;
	import flash.geom.ColorTransform;
	import flash.utils.Timer;
	import metaswarm.node.NodeState;
	
	public class PickedState implements NodeState{
		
		private var node:Node;
		
		private static var redTransform:ColorTransform;
		private static var bluTransform:ColorTransform;
		private static var blkTransform:ColorTransform;
		private static var whtTransform:ColorTransform;
		
		public function PickedState(node:Node)
		{
			//trace("construct PickedState");
			this.node = node;
			
			redTransform = new ColorTransform( );
			redTransform.color = 0xFF0000;
			bluTransform = new ColorTransform( );
			bluTransform.color = 0x0000ff;
			blkTransform = new ColorTransform( );
			blkTransform.color = 0x231F20;
			whtTransform = new ColorTransform( );
			whtTransform.color = 0xFFFFFF;
		}
		public function select():void{}
		
		public function deSelect():void{
			//trace("PickedState deselect");
			stopFocus();
			node.icon.visible = false;
			node.tag.visible = false; //not working
			
			//restore dot
			node.dot.x = node.icon.x;
			node.dot.y = node.icon.y;
			node.dot.setTarget(node.icon.x, node.icon.y);
			node.dot.visible = true;
			
			node.nodeState = node.idle;
		}
		
		public function toggleSelect():void{
			deSelect();
		}
		
		public function drag():void{
			//trace("PickedState drag: goto dragging state");
			stopFocus();
			
			//position dot at icon so icon can find its
			//way back if thumb is closed
			node.dot.x = node.icon.x;
			node.dot.y = node.icon.y;
			
			//node.dataBox.alpha = 50;
			node.icon.startDrag();
			//node.dot.visible = false;
			//node.icon.visible = false;
			//node.thumb.visible = false;
			
			//remove tag
			node.tag.visible = false;
			
			//show meta & img
			//node.dataBox.visible = true;
			//node.thumb.visible = true;
			
			//load thumb
			node.thumb.visible = false;
			node.thumb.load(node.dat[0] + node.dat[1]);
			node.thumb.make();
			node.thumb.x = node.icon.x;
			node.thumb.y = node.icon.y;
			node.addChild(node.thumb);
			
			//transition to drag state
			node.nodeState = node.dragging;
		}
		
		public function drop():void{
			//trace("PickedState drag: goto dragging state");
			stopFocus();
			
			//position dot at icon so icon can find its
			//way back if thumb is closed
			node.dot.x = node.icon.x;
			node.dot.y = node.icon.y;
			
			//node.dataBox.alpha = 50;
			//node.icon.startDrag();
			//node.dot.visible = false;
			//node.icon.visible = false;
			//node.thumb.visible = false;
			
			//remove tag
			node.tag.visible = false;
			
			//show meta & img
			//node.dataBox.visible = true;
			//node.thumb.visible = true;
			
			//load thumb
			node.thumb.visible = true;
			node.thumb.load(node.dat[0] + node.dat[1]);
			node.thumb.make();
			node.thumb.x = node.icon.x;
			node.thumb.y = node.icon.y;
			node.addChild(node.thumb);
			
			//---
			
			//trace("PickedState drag: goto dragging state");
			//node.icon.visible = false;
			
			//node.icon.stopDrag();
			//node.thumb.stopDrag();
			
			//node.thumb.x = node.icon.x;
			//node.thumb.y = node.icon.y;
			node.thumb.setTarget(node.icon.x, node.icon.y);
			//node.thumb.visible = true;
			
			//transition to drag state
			node.nodeState = node.dropped;
		}
		
		//public function dropThumb():void{}
		
		public function popout():void{}
		
		public function popin():void{}
		
		public function close():void{}
		
		public function setTarget(tgx:Number,
						   		  tgy:Number):void{
			//trace("PickedState switch");
			
			//set new icon target only
			node.icon.setTarget(tgx, tgy);
			
		}
		
		public function rePosition():void{
			//trace("PickedState rePosition");
			
			//update dot position
			node.icon.goToTarget();
			
			//snap tag to new dot position
			node.tag.x = node.icon.x;
			node.tag.y = node.icon.y;
			
			//snap dot to new icon position
			//node.dot.x = node.icon.x;
			//node.dot.y = node.icon.y;
			
			//snap icon to new dot position
			/*node.icon.x = node.dot.x;
			node.icon.y = node.dot.y;*/
		}
		
		public function reSize():void{
			//trace("PickedState reSize");
			node.icon.scaleToTarget();
		}
		
		public function startFocus():void{
			//trace("startFocus");
			node.icon.iconButton.forceOver();
			node.tag.x = node.icon.x;
			node.tag.y = node.icon.y;
			//node.tag.visible = true;
			node.tag.t.borderColor = 0xFF0000;
		}
		public function stopFocus():void{
			//trace("stopFocus");
			node.icon.iconButton.restoreOver();

			//node.tag.visible = false;
			node.tag.t.borderColor = 0xCCCCCC;
		}
		
		public function startHover():void{
			//trace("");
			//node.tag.transform.colorTransform = whtTransform;
			
			//zoom in icon
			node.icon.setTargetWidth(12);
			node.tag.x = node.icon.x;
			node.tag.y = node.icon.y;
			node.tag.visible = true;
		}
		
		public function stopHover():void{
			//trace("");
			//node.tag.transform.colorTransform = blkTransform;
			
			//zoom back out
			node.icon.setTargetWidth(6);
			node.tag.visible = false;
		}
	}
}
package metaswarm.node.nodestates   {
	import metaswarm.node.NodeState;
	
	public class PoppedState implements NodeState{
		
		private var node:Node;
		
		public function PoppedState(node:Node)
		{
			//trace("construct DroppedState");
			this.node = node;
		}
		
		public function select():void{}
		public function deSelect():void{}
		public function toggleSelect():void{}
		
		public function drag():void{
			//trace("DroppedState drag: goto dragging state");
			
			//start dragging
			node.thumb.startDrag();
			
			//goto to dragging state
			node.nodeState = node.tdragging;
			node.prevState = node.popped;
		}
		
		public function drop():void{}
		//public function dropThumb():void{}
		public function popout():void{}
		
		public function popin():void{
			//trace("DroppedState popout");
			
			//position dataBox next to thumb and show
			node.dataBox.visible = false;
			
			//goto popped state
			node.nodeState = node.dropped;
		}
		
		public function close():void{
			//trace("DroppedState close");
			
			//position dot at target
			node.dot.snapToTarget();
			
			//position icon at thumb position
			node.icon.x = node.thumb.x;
			node.icon.y = node.thumb.y;
			node.icon.setTarget(node.dot.x, node.dot.y);
			node.icon.visible = true;
			
			node.thumb.visible = false; //hmm should i dispose of bitmap???
			node.dataBox.visible = false;
			
			node.nodeState = node.picked;
		}
		
		public function setTarget(tgx:Number,
						   		  tgy:Number):void{
			//trace("DroppedState switch");
			
			//preview mainstate needs this to tile
			//node.thumb.setTarget(tgx, tgy);
			
			//set dot target incase thumb is closed, 
			//dot it will get back in place in swarm
			node.dot.setTarget(tgx, tgy);
		}
		
		public function rePosition():void{
			//trace("DroppedState rePosition");
			
			//preview mainstate need this to tile 
			node.thumb.goToTarget();
			
			//snap databox to thumb location
			node.dataBox.x = node.thumb.x + 125;
			node.dataBox.y = node.thumb.y;
			
			
		}
		
		public function startFocus():void{}
		public function stopFocus():void{}
		public function reSize():void{} //icon is not visible so don't bother
		public function startHover():void{} //change these names to hover or smth
		public function stopHover():void{}
		
	}
}
package metaswarm.node.nodestates   {
	import metaswarm.node.NodeState;
	
	public class ThumbDraggingState implements NodeState{
		
		private var node:Node;
		
		function ThumbDraggingState(node:Node)
		{
			//trace("construct DraggingState");
			this.node = node;
		}
		public function select():void{}
		
		public function deSelect():void{}
		
		public function toggleSelect():void{}
		
		public function drag():void{}
		
		public function drop():void{
			//trace("PickedState drag: goto dragging state");
			//node.icon.visible = false;
			
			//node.icon.stopDrag();
			node.thumb.stopDrag();
			
			//node.thumb.x = node.icon.x;
			//node.thumb.y = node.icon.y;
			node.thumb.setTarget(node.thumb.x, node.thumb.y);
			//node.thumb.visible = true;
			
			//goto dropped state
			node.nodeState = node.prevState;
		}
		
		//public function dropThumb():void{}
		
		public function popout():void{}
		
		public function popin():void{}
		
		public function close():void{}
		
		public function setTarget(tgx:Number,
						   		  tgy:Number):void{
			//trace("DraggingState switch");
			//node.dot.setTarget(tgx, tgy);
		}
		
		public function rePosition():void{
			//trace("DraggingState rePosition");
			//node.dot.goToTarget();
			//node.thumb.x = node.icon.x;
			//node.thumb.y = node.icon.y;
			
			//dragging icon so snap dot to icon
			/*node.dot.x = node.dataBox.x;
			node.dot.y = node.dataBox.y;*/
			
			//snap data box to thumb while dragging
			node.dataBox.x = node.thumb.x + 125;
			node.dataBox.y = node.thumb.y;
		}
		
		public function reSize():void{
			//trace("DraggingState reSize");
			node.icon.scaleToTarget(); //???
		}
		
		public function startFocus():void{}
		
		public function stopFocus():void{}
		
		public function startHover():void{}
		
		public function stopHover():void{}
	}
}
package metaswarm.scrap   {
	import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.Shape;
	import flash.display.Sprite;
	import metaswarm.node.components.Particle;
	
	
	public class Box extends Particle{
		
		private static const Z_EASE:Number 	= 1;
		private static const Z_SNAP:Number 	= 1;
		
		//Target zoom
		private var tgw:Number;
		
		//radial distance to zoom target
		private var dw:Number;
		
		//zoom velocity
		private var vw:Number;
		
		public function Box(tgw:Number=0,
							dw:Number=0,
							vw:Number=0):void
		{
			this.x = 0;
			this.y = 0;
			this.tgw = tgw;
			this.dw = dw;
			this.vw = vw;
			init();
		}
		public function init():void {
			visible = false;
			focusRect = true;
			tabEnabled = true;
			doubleClickEnabled = true;
			//mouseEnabled = false;
		}
		
		public function load():void{
			//
		}
		//might depend on load later, so keep here
		//rather than put in init
		public function make():void{
			this.graphics.beginFill(0x0000ff);
			this.graphics.lineStyle(0);
			this.graphics.drawRect(0, 0, 10, 10);
			this.graphics.endFill();
			
		}
		
		public function scaleToTarget():void {
			dw = tgw - this.width;
			if(Math.abs(dw - Z_SNAP)<1){
				this.width = tgw;
				this.height = tgw;
				//removeEventListener(Event.Enter_FRAME, onEnterFrame);
			}else{
				vw = dw * Z_EASE;
				this.width += vw;
				this.height += vw;
			}
		}
				
		public function setTargetWidth(a:Number) {
			tgw = a;
		}
	}
}
			
package metaswarm.scrap   {
	import flash.display.DisplayObject;
    import flash.display.Graphics;
    import flash.display.Shape;
	import flash.display.Sprite;
	import metaswarm.node.components.Particle;
	
	public class Cross extends Particle{
		
		public function Cross():void{
			init();
		}
		public function init():void {
			//visible = true;
			//focusRect = true;
			//tabEnabled = true;
		}
		
		public function load():void{
			//
		}
		//might dep on load later, so leave here!
		public function make():void{
			//trace("cross.make()");
			this.graphics.lineStyle(0);
			//this.graphics.lineStyle(1, 0xFF0000);
			this.graphics.moveTo(x, y-3);
			this.graphics.lineTo(x, y+3);
			this.graphics.moveTo(x-3, y);
			this.graphics.lineTo(x+3, y);
			/*trace("visible: " + this.visible);
			trace("x: " + this.x);
			trace("y: " + this.y);*/
		}
	}
}
		
		
package metaswarm.scrap   {
	import flash.display.*;
	import flash.events.*;
    import flash.net.URLRequest;
    import metaswarm.node.components.thumb.BitmapLoadr;
    import metaswarm.node.components.Particle;
	
	public class Image extends Particle{
		
		var path:String;
		var ldr:BitmapLoadr;
		var bmp:Bitmap;
		var bmpLoaded:Boolean;
		
		public function Image():void {
			ldr = new BitmapLoadr(this);
			bmp = new Bitmap();
			bmpLoaded = false;
			init();
		}
		public function init():void {
			addChild(ldr);
			//l.loadImg("fake string");
			
			visible = false;
			//focusRect = true;
			//tabEnabled = true;
		}
		
		public function load(path:String):void{
			this.path = path;
		}
		public function make():void{
			if(!bmpLoaded){
				ldr.loadBmp(path);
				bmpLoaded = true;
			}
		}
		
	}
}
package metaswarm.scrap   {
  import flash.display.*;
  import flash.text.*;
  import flash.events.*
  import flash.net.*;
  
  public class Loadr extends Sprite {
	  
	var loadProg:TextField;  
	var gnurbwurk:Metaswarm;
	
    public function Loadr(gnurbwurk:Metaswarm) 
	{
		this.gnurbwurk = gnurbwurk;
		this.loadProg = new TextField();
		
		init();
    }
    
    private function init():void 
	{ 
      	//loadProg.width = stage.stageWidth;
      	//loadProg.height = stage.stageHeight;   
      	addChild(loadProg);  
    }
	
	public function preload():void {
			  
		var loader:URLLoader = new URLLoader();
			  
		// Instruct the loader to read the file as plain text - This line is not
		// necessary because the dataFormat is DataFormat.TEXT by default.
		loader.dataFormat = URLLoaderDataFormat.TEXT;
			  
		// Register an event handler for when the data is finished downloading
		loader.addEventListener(Event.COMPLETE, loadComplete);
		
		// Listen for the progress event to check download progress
      	loader.addEventListener(ProgressEvent.PROGRESS, handleProgress);
 
		// Load the HTML text from the example.html file
		loader.load(new URLRequest("../assets/index4.txt"));
    }
		
	private function handleProgress(event:ProgressEvent):void 
	{
      	// Calculate the percentage by multiplying the loaded-to-total 
      	// ratio by 100
      	var percent:Number = Math.round(event.bytesLoaded 
                                      / event.bytesTotal * 100 );
      
      	loadProg.text = " Loaded: " + event.bytesLoaded + "\n"
                        + "  Total: " + event.bytesTotal + "\n"
                        + "Percent: " + percent;
						
		//trace(loadProg.text);
    }

	
    private function loadComplete(event:Event):void 
	{
		var loader:URLLoader = URLLoader(event.target);
			  
		// assign to output. The data property of the URLLoader is the file contents.
		parseData(loader.data);
    }
	
	private function parseData(loadedData:String):void 
	{
		var parsedData:Array = new Array();
		//var parsedMenu:Array = new Array();
		
		// Split the string into an array of words using a space as the delimiter.
		var lines:Array = loadedData.split("\n");
		var words:Array = new Array();
			
		// Loop through the array and do something with each word. 
		// In this example, just output the values.
		for ( var i:int = 0; i < lines.length; i++ ) {
			words = lines[i].split("\t");
			parsedData.push(words);
			 //trace(parsedData[i][1]);
		}
		//gnurbwurk.parsedData = parsedData;
		//gnurbwurk.preloadComplete(parsedData);
		gnurbwurk.load(parsedData);
		//gnurbwurk.main.makePatterns();
	}
  
  }//end class
}//end pkg
package metaswarm.subset    {
	import flash.display.DisplayObject;
	import flash.display.Sprite;
	import flash.display.Graphics;
    import flash.display.Shape;
	
	public class Subset extends Sprite{
		
		public var nodes:Array;
		public var tiler:SubsetTiler;
		//var count:uint;
		
		//constructor:	
		public function Subset(){
			nodes = new Array();
			tiler = new SubsetTiler(this);
		}
		
		public function tile():void {
			//trace("tile");
			tiler.grid();
		}
		
		public function restore():void {
			//trace("tile");
			tiler.restore();
		}
		
		public function disable():void {
			trace("disable");
			for(var i:uint=0; i<nodes.length; i++){
				nodes[i].visible = false;
			}
		}
		
	}//end class
}//end pkg
package metaswarm.subset    {
	import flash.display.DisplayObject;
	import flash.display.Sprite;
	import flash.display.Graphics;
    import flash.display.Shape;
	
	public class SubsetTiler extends Sprite{
		
		public var subset:Subset;
		//var tileSize:uint;
		
		//constructor:	
		public function SubsetTiler(subset:Subset){
			this.subset = subset;
			//this.tileSize = 100; //later define dynamically
		}
		
		//this is beastly for now. it sets target of both databox
		//and tag, regardless of whether dropped or picked called it.
		//and s should not be hard coded!!
		public function grid():void{
			//trace("tiler.grid");
			var s:uint = 100;
			var cnt:uint = subset.nodes.length;
			//trace("cnt: " + cnt);
			//var xMargin:uint = s/4;
    		//var yMargin:uint = s/4;
			var xsp:uint = s*2;
			var ysp:uint = s + s/4;
			var cols:uint = Math.ceil(((s+ysp) * cnt) / 1080);
			//trace("cols: " + cols);
			var xoff:uint = s/4;
			var yoff:uint = s/4;
			
			for(var i:uint=0; i<cnt; i++){
				//trace("subset.nodes[i].thumb.x: " + subset.nodes[i].meta.x);
				//trace("subset.nodes[i].thumb.y: " + subset.nodes[i].meta.y);
				var px:Number = subset.nodes[i].thumb.x;
				var py:Number = subset.nodes[i].thumb.y;
				subset.nodes[i].thumb.setPrev(px, py);
				//
				var tgx:Number = xoff + xsp*(i%cols);
				var tgy:Number = yoff + ysp*Math.floor(i/cols);
				subset.nodes[i].popout();
				subset.nodes[i].thumb.setTarget(tgx, tgy);
				//subset.nodes[i].tag.setTarget(tgx, tgy);
			}
		}
		
		public function restore():void{
			//trace("tiler.restore");
			var cnt:uint = subset.nodes.length;
			for(var i:uint=0; i<cnt; i++){
				//trace("subset.nodes[i].thumb.x: " + subset.nodes[i].meta.x);
				//trace("subset.nodes[i].thumb.y: " + subset.nodes[i].meta.y);
				var tgx:Number = subset.nodes[i].thumb.px;
				var tgy:Number = subset.nodes[i].thumb.py;
				subset.nodes[i].popin();
				subset.nodes[i].thumb.setTarget(tgx, tgy);
				//subset.nodes[i].tag.setTarget(tgx, tgy);
			}
		}
		
	}//end class
}//end pkg
package metaswarm.swarm    {
	import flash.display.DisplayObject;
	import flash.display.Sprite;
	import flash.display.Graphics;
    import flash.display.Shape;
    import metaswarm.swarm.swarmstates.BrowningState;
    import metaswarm.swarm.swarmstates.GridState;
    import metaswarm.swarm.swarmstates.LorenzeState;
    import metaswarm.swarm.swarmstates.ScatterState;
    import metaswarm.swarm.swarmstates.TypeState;
    import metaswarm.swarm.swarmstates.MapState;
    import metaswarm.subset.Subset;
	
	public class Swarm extends Sprite{
		
		//omit constants for now
		
		//Except for TextField and Video objects, 
		//a display object with no content has a 
		//width of 0, even if you try to set width 
		//to a different value, so need these
		public var w:int;
		public var h:int;
		
		//internal composite objects
		public var nodes:Array;
		public var nodeCnt:uint;
		public var propCnt:uint;
		public var sortOrder:uint;
		
		//internal states
		public var lorenze:SwarmState;
		public var browning:SwarmState;
		public var scatter:SwarmState;
		public var grid:SwarmState;
		public var type:SwarmState;
		public var map:SwarmState;
		
		//internal state holder
		public var swarmState:SwarmState;
		
		//var swarmLoader:SwarmLoader;
		//var patternMaker:PatternMaker;
		
		//constructor:	
		public function Swarm(){
			
			//instantiate composite objs
			nodes = new Array();
			
			lorenze = new LorenzeState(this);
			browning = new BrowningState(this);
			scatter = new ScatterState(this);
			grid = new GridState(this);
			type = new TypeState(this);
			map = new MapState(this);
			
			init();
		}
		private function init():void{
			//set intial state and show unique 
			//tags for that state
			swarmState = grid;
			sortOrder = 2;
			showUniqueTags();
		}
		
		
		//these need to be changed
		public function preview():void {
			var dropped:Subset = new Subset();
			//var undropped:Subset = new Subset();
			for(var i:uint=0; i<nodeCnt; i++){
				if(nodes[i].isDropped() || nodes[i].isPopped()){
					dropped.nodes.push(nodes[i]);
				}else{
					//undropped.push(nodes[i]);
					nodes[i].visible = false;
				}
			}
			dropped.tile();
			//undropped.disable();
		}
		
		public function explore():void {
			var dropped:Subset = new Subset();
			//var undropped:Subset = new Subset();
			for(var i:uint=0; i<nodeCnt; i++){
				if(nodes[i].isDropped() || nodes[i].isPopped()){
					dropped.nodes.push(nodes[i]);
				}else{
					//undropped.push(nodes[i]);
					nodes[i].visible = true;
				}
			}
			dropped.restore();
			//undropped.disable();
		}
		
		//methods
		public function select(node:Node):void {
			clearSelection();
			node.select();
		}
		public function add(node:Node):void {
			node.select();
		}
		public function remove(node:Node):void {
			node.deSelect();
		}
		public function toggleSelect(node:Node):void {
			node.toggleSelect();
		}
		public function clearSelection():void {
			for(var i:uint=0; i<nodeCnt; i++){
				nodes[i].deSelect();
			}
		}
		public function selectBy(t:String):void {
			clearSelection();
			for(var i:uint=0; i<nodeCnt; i++){
				if(nodes[i].tag.t.text == t){
					nodes[i].select();
				}
			}
		}
		public function addBy(t:String):void {
			for(var i:uint=0; i<nodeCnt; i++){
				if(nodes[i].tag.t.text == t){
					nodes[i].select();
				}
			}
		}
		public function filterBy(t:String):void {
			for(var i:uint=0; i<nodeCnt; i++){
				if(nodes[i].tag.t.text != t){
					//trace("deSelect");
					nodes[i].deSelect();
				}
			}
		}
		public function popin(node:Node):void{
			node.popin();
		}
		public function popout(node:Node):void{
			node.popout();
		}
		
		public function close(node:Node):void{
			node.close();
		}
		
		public function drag(node:Node):void{
			node.drag();
		}
		
		public function drop(node:Node):void{
			node.drop();
		}
		public function dropSelected():void{
			for(var i:uint=0; i<nodeCnt; i++){
				if(nodes[i].isPicked()){
					nodes[i].drop();
				}
			}
		}
		public function startHover(node:Node):void{
			node.startHover();
		}
		
		public function stopHover(node:Node):void{
			//trace("swarm.stopHover");
			node.stopHover();
		}
		
		public function startFocusBy(t:String):void {
			for(var i:uint=0; i<nodeCnt; i++){
				if(nodes[i].tag.t.text == t){
					nodes[i].startFocus();
				}
			}
		}
		
		public function startSelectByFocus(t:String):void {
			for(var i:uint=0; i<nodeCnt; i++){
				if(nodes[i].tag.t.text == t){
					nodes[i].startFocus();
				}
			}
		}
		
		public function startFilterByFocus(t:String):void {
			for(var i:uint=0; i<nodeCnt; i++){
				if(nodes[i].tag.t.text == t && nodes[i].isPicked()){
					nodes[i].startFocus();
				}
			}
		}
		
		public function stopFocusBy():void {
			for(var i:uint=0; i<nodeCnt; i++){
				nodes[i].stopFocus();
			}
		}
		
		public function printOutNodes():void{
			trace("printOutCoordinates: *****************************************************");
			for(var i:uint=0; i<nodeCnt; i++){
				trace("node " + i + ": ");
				for(var j:uint=0; j<propCnt; j++){
					trace("xpos,ypos " + j + ": " + nodes[i].xpos[0][j] + ", " + nodes[i].ypos[0][j]);
				}
			}
		}
		
		public function rePosition():void{
			//trace("swarm rePosition");
			for(var i:uint=0; i<nodeCnt; i++){
				nodes[i].rePosition();
			}
		}
		
		public function reSize():void{
			//trace("swarm reSize");
			for(var i:uint=0; i<nodeCnt; i++){
				nodes[i].reSize();
			}
		}
		
		public function incrSort():void{
			//trace("incrSort");
			if(sortOrder < propCnt-1){
				sortOrder++;
			}else{
				sortOrder = 0;
			}
			for(var i:uint=0; i<nodeCnt; i++){
				//swarm.nodes[i].tag.setTxt(1);
				nodes[i].tag.incr();
			}
			setPattern();
			showUniqueTags();
		}
		public function decrSort():void{
			//trace("decrSort");
			if(sortOrder > 0){
				sortOrder--;
			}else{
				sortOrder = propCnt-1;
			}
			for(var i:uint=0; i<nodeCnt; i++){
				//swarm.nodes[i].tag.setTxt(1);
				nodes[i].tag.decr();
			}
			setPattern();
			showUniqueTags();
		}
		
		
		public function showUniqueTags():void{
			for(var i:uint=0; i<nodeCnt; i++){
				nodes[i].tag.visible = nodes[i].tag.isUniq;
			}
		}
		
		
		//delegated tasks*********************************************
		public function incrState():void{
			//trace("delegate incrState");
			swarmState.incrState();
		}
		public function decrState():void{
			//trace("delegate decrState");
			swarmState.decrState();
		}
		public function setPattern():void{
			//trace("delegate swarm switch");
			swarmState.setPattern();
		}
		
	}//end swarm
}//end pkg
		
		
package metaswarm.swarm    {
  import flash.display.*;
  import flash.text.*;
  import flash.events.*
  import flash.net.*;
  import metaswarm.node.NodeLoader;
  import metaswarm.*;
  
  public class SwarmLoader extends Sprite {
	    
	private var _swarm:Swarm;
	
    public function SwarmLoader(swarm:Swarm) 
	{
		this._swarm = swarm;
		//this.loadProg = new TextField();
		
		init();
    }
    
    private function init():void 
	{ 
      	//loadProg.width = stage.stageWidth;
      	//loadProg.height = stage.stageHeight;   
      	//addChild(loadProg);  
    }
	
	public function load(dat:Array):void{
		//trace("swarmloader load");
		_swarm.nodeCnt = dat.length;
		_swarm.propCnt = dat[0].length;
		//create nodes and add each to display list
		for(var i:uint=0; i<_swarm.nodeCnt; i++){
			var tmp:Node = new Node();
			var nodeLoader:NodeLoader = new NodeLoader(tmp);
			
			nodeLoader.load(dat[i]); //maybe call after push
			_swarm.nodes.push(tmp);
		}
	}
	public function make():void{
		//swarm.patternMaker.make(); //decouple from swarm
		for(var i:uint=0; i<_swarm.nodeCnt; i++){
			var nodeLoader:NodeLoader = new NodeLoader(_swarm.nodes[i]);
			nodeLoader.make();
		}
	}
	public function go():void{
		//swarm.swarmState = swarm.grid;
		//swarm.sortOrder = 0;
		for(var i:uint=0; i<_swarm.nodeCnt; i++){
			var nodeLoader:NodeLoader = new NodeLoader(_swarm.nodes[i]);
			nodeLoader.go();
			_swarm.addChild(_swarm.nodes[i]);
		}
		//swarm.setPattern();
	}
	
  }//end class
}//end pkg
package metaswarm.swarm    {
	
	//fsm interface
	public interface SwarmState{
		
		//internal interface methods
		//function incrSort():void;
		//function decrSort():void;
		function incrState():void;
		function decrState():void;
		function setPattern():void;
	}
}
package metaswarm.swarm.patternmaker   {
	import flash.display.*;
	import flash.utils.*;
	import flash.events.*;
	import flash.geom.*;
	import flash.text.*;
	import metaswarm.swarm.patterns.GeoMapper;
	import metaswarm.swarm.patterns.LorenzeMaker;
	import metaswarm.swarm.patterns.TypeMaker;
	import metaswarm.swarm.Swarm;
	import metaswarm.swarm.patterns.GridMaker;
	
	//class needs to be broken up
	
	public class PatternMaker extends Sprite{
		
		private var _swarm:Swarm;
		//var typeMaker:TypeMaker; //don't know why i don't localize to function
		
		public function PatternMaker(swarm:Swarm):void{
			this._swarm = swarm;
			//this.typeMaker = new TypeMaker();
		}
		
		public function make():void
		{
			//property count is hardcoded for now so can't
			//add/remove patterns w/out changing
			for(var j:uint=0; j<_swarm.propCnt; j++){
			  sortBy(j);
			  setUniqueTags(j);
			  grid(0, j);
			  scatter(1, j);
			  browning(2, j);
			  lorenze(3, j);
			  type(4,j);
			  map(5,j);
			}
		}
		
		public function setUniqueTags(tid:uint):void{
			var prevTag:String = new String();
			var curTag:String = new String();
			prevTag = "";
			for(var i:uint=0; i<_swarm.nodeCnt; i++){
				curTag = _swarm.nodes[i].dat[tid];
				if(curTag == prevTag){
					_swarm.nodes[i].tag.uniqArr[tid] = false;
				}else{
					_swarm.nodes[i].tag.uniqArr[tid] = true;
				}
				prevTag = _swarm.nodes[i].dat[tid];
			}
		}
		
		public function type(pid:uint, sid:uint):void
		{
			//trace("PatternMaker->type()");
			
			//generate coordinates
			var typeMaker:TypeMaker = new TypeMaker();
			var points:Array = typeMaker.make("me++", _swarm.nodeCnt, _swarm.w);
		
			//map coordinates to nodes positions
			for(var i:uint=0; i<_swarm.nodeCnt; i++){			
				_swarm.nodes[i].xpos[pid][sid] = points[i][0];
				_swarm.nodes[i].ypos[pid][sid] = points[i][1];
			}
		}
		
		//this is beastly for now
		public function grid(pid:uint, sid:uint):void
		{
			//generate coordinates
			var gridMaker:GridMaker = new GridMaker();
			var points:Array = gridMaker.make(_swarm.nodeCnt, _swarm.w, _swarm.h);
			
			//map coordinates to nodes positions
			for(var i:uint=0; i<_swarm.nodeCnt; i++){			
				_swarm.nodes[i].xpos[pid][sid] = points[i][0];
				_swarm.nodes[i].ypos[pid][sid] = points[i][1];
			}
		}
		
		public function scatter(pid:uint, sid:uint):void
		{
			for(var i:uint=0; i<_swarm.nodeCnt; i++){	
				_swarm.nodes[i].xpos[pid][sid] = Math.random()*_swarm.w;
				_swarm.nodes[i].ypos[pid][sid] = Math.random()*_swarm.h;
    		}
		}
		
		//Lorenze Attractor Pattern-just guessed on random range
		public function lorenze(pid:uint, sid:uint):void
		{
			//generate coordinates
			var lorenzeMaker:LorenzeMaker = new LorenzeMaker();
			var points:Array = lorenzeMaker.make(_swarm.nodeCnt, _swarm.w, _swarm.h);
			
			//map coordinates to nodes positions
			for(var i:uint=0; i<_swarm.nodeCnt; i++){			
				_swarm.nodes[i].xpos[pid][sid] = points[i][0];
				_swarm.nodes[i].ypos[pid][sid] = points[i][1];
			}
		}
		
		/*//genBrowning
		public function browning(pid:uint, sid:uint):void{
			var range:int = 20;
			swarm.nodes[0].xpos[pid][sid] = Math.random()*swarm.w;
			swarm.nodes[0].ypos[pid][sid] = Math.random()*swarm.h;
			for(var i:uint=1; i<swarm.nodeCnt; i++){
				if(swarm.nodes[i].tag.dat[sid] == swarm.nodes[i-1].tag.dat[sid]){
				  	swarm.nodes[i].xpos[pid][sid] = swarm.nodes[i-1].xpos[pid][sid] + (Math.random()-.5)*range;
				  	swarm.nodes[i].ypos[pid][sid] = swarm.nodes[i-1].ypos[pid][sid] + (Math.random()-.5)*range;
				}else{
					swarm.nodes[i].xpos[pid][sid] = Math.random()*swarm.w;
					swarm.nodes[i].ypos[pid][sid] = Math.random()*swarm.h;
				}
			}
		}*/
		
		//genBrowning
		public function browning(pid:uint, sid:uint):void
		{
			var range:int = 25;
			_swarm.nodes[0].xpos[pid][sid] = _swarm.w/2;
			_swarm.nodes[0].ypos[pid][sid] = _swarm.h/2;
			for(var i:uint=1; i<_swarm.nodeCnt; i++){
				_swarm.nodes[i].xpos[pid][sid] = _swarm.nodes[i-1].xpos[pid][sid] + (Math.random()-.5)*range;
				_swarm.nodes[i].ypos[pid][sid] = _swarm.nodes[i-1].ypos[pid][sid] + (Math.random()-.5)*range;
			}
		}
		
		//genBrowning
		public function map(pid:uint, sid:uint):void
		{
			var geoMapper:GeoMapper = new GeoMapper();
			
			//var coordinates:Array = new Array();
			var latIndex:Number = 6;
			var longIndex:Number = 5;
			
			//for each node
			for(var i:uint=1; i<_swarm.nodeCnt; i++){
				var geoPoint:Array = [_swarm.nodes[i].dat[longIndex], _swarm.nodes[i].dat[latIndex]];
				//coordinates.push(geoPoint);
				
				//convert node.dat to screen coordinates
				var point:Array = geoMapper.geoToScreen(geoPoint, _swarm.h/2);
				
				//assign to node pos
				_swarm.nodes[i].xpos[pid][sid] = point[0];
				_swarm.nodes[i].ypos[pid][sid] = point[1];
			}
		}
		
		//bubble sort. put in util class later
		public function sortBy(tid:uint):void
		{
			var a:Node = new Node();
			var b:Node = new Node();
			for(var i:uint=0; i<_swarm.nodeCnt; i++){
				for(var j:uint=0; j<_swarm.nodeCnt; j++){
					//assign neighbooring Nodes to tmp nodes
					a = _swarm.nodes[i];
          			b = _swarm.nodes[j];
					//if two strings not alphabetized then swap them
          			if(a.tag.dat[tid] > b.tag.dat[tid]){
						//swap
						//trace("swap: " + a.tag.dat[sid] + " with " + b.tag.dat[sid]);
						_swarm.nodes[i] = b;
						_swarm.nodes[j] = a;
					}
				}
			} 
		}
		
	}//end class
}//end pkg
	
package metaswarm.swarm.patterns   {
import flash.display.*;
import flash.utils.*;
import flash.events.*;
import flash.geom.*;
import flash.text.*;

	public class BrowningMaker extends Sprite {
		
		//lorenze constants - do not change
		//private static const XXX:Number = xxx;
		
		public function BrowningMaker():void{
		}
		
		//returns a matrix of 2d coordinates
		public function make(numOfPoints:uint, w:uint, h:uint):Array
		{
			var points:Array = new Array();
			
			return points;
		}
		
	}//end class
}//end pkg
package metaswarm.swarm.patterns   {
import flash.display.*;
import flash.events.*;
import flash.geom.*;
import flash.text.*;
import flash.utils.*;

	public class GeoMapper extends Sprite {
		
		// map dependant
		private static const LONG_INIT:Number = -180;
		private static const LAT_INIT:Number = 90;
		private static const LONG_FINAL:Number = 180;
		private static const LAT_FINAL:Number = -90;
		private static const LONG_DELTA:Number = 360;
		private static const LAT_DELTA:Number = 180;
		
		public function GeoMapper():void{
		}
		
		//returns a matrix of 2d coordinates
		public function map(geoPoints:Array, mapHeight:uint):Array
		{
			var points:Array = new Array();
			
			//lorenze iterative functions
			for(var i:uint=0; i<geoPoints.length; i++){
				//set next point coordinate
				var nextPoint:Array = geoToScreen(geoPoints[i], mapHeight);
				points.push(nextPoint);
			}
			return points;
		}
		
		//returns a matrix of 2d coordinates
		public function geoToScreen(geoPoint:Array, mapHeight:uint):Array
		{
			var long:Number = geoPoint[0];
			var lat:Number = geoPoint[1];
			var mapWidth:uint = mapHeight*2;
			
			var px:Number = (long + 180) * (mapWidth/360);
			var py:Number = (lat - 90) * (mapHeight/180) * -1; 
			
			var point:Array = [px, py];

			return point;
		}
		
	}//end class
}//end pkg
package metaswarm.swarm.patterns   {
import flash.display.*;
import flash.utils.*;
import flash.events.*;
import flash.geom.*;
import flash.text.*;

	public class GridMaker extends Sprite {
		
		//minimum size that text can be rastered at to provide
		//adequate sampling for large display
		//private static const FONTSIZE:Number = 42;
		
		public function GridMaker():void{
		}
		
		//returns a matrix of 2d coordinates
		public function make(numOfPoints:uint, w:uint, h:uint):Array
		{
			var points:Array = new Array();
			
			//trace("for pattern: " + pid + ", and sortOrder: " + sid + ": "); 
			var xMargin:uint = 5;
    		var yMargin:uint = 3;
			var cols:uint = Math.round(Math.sqrt(numOfPoints));
			var xsp:uint = w/(cols+xMargin);
			var ysp:uint = h/(cols+yMargin);
			var xoff:uint = (w - xsp*cols)/2;
			var yoff:uint = (h - ysp*cols)/2;
			
			for(var i:uint=0; i<numOfPoints; i++){
				
				var px:Number = xoff + xsp*(i%cols);
				var py:Number = yoff + ysp*Math.floor(i/cols);
				var nextPoint:Array = [px, py]
				points.push(nextPoint);
			}
			
			return points;
		}
		
	}//end class
}//end pkg
package metaswarm.swarm.patterns   {
import flash.display.*;
import flash.utils.*;
import flash.events.*;
import flash.geom.*;
import flash.text.*;

	public class LorenzeMaker extends Sprite {
		
		//lorenze constants - do not change
		private static const H:Number = 0.01;
		private static const A:Number = 10.0;
		private static const B:Number = 28.0;
		private static const C:Number = 8.0/3.0;
		
		public function LorenzeMaker():void{
		}
		
		//returns a matrix of 2d coordinates
		public function make(numOfPoints:uint, w:uint, h:uint):Array
		{
			var points:Array = new Array();
			
			var sf:Number = h/300; //scale factor. adjust by steping divisor by 100
			var xoff:uint = w/2;
			var yoff:uint = h/2;
			var x0:Number = (Math.random() * 10) / 10;
			var y0:Number = Math.random() * 20;
			var z0:Number = Math.random() * 10;
			
			//lorenze iterative functions
			for(var i:uint=0; i<numOfPoints; i++){
				var x1:Number = x0 + H * A * (y0-x0);
				var y1:Number = y0 + H * (x0 * (B - z0) - y0);
				var z1:Number = z0 + H * (x0 * y0 - C * z0);
				
				//set next point coordinate
				var px:Number = (x0 * 10) * sf + xoff;
				var py:Number = (y0 * 10) * sf + yoff;
				var nextPoint:Array = [px, py]
				points.push(nextPoint);
				
				//feedback
				x0 = x1;
				y0 = y1;
				z0 = z1;
			}
			return points;
		}
		
	}//end class
}//end pkg
// map dependant
var LONG_INIT = -180;
var LAT_INIT = 90;
var LONG_FINAL = 180;
var LAT_FINAL = -90;
var LONG_DELTA = 360;
var LAT_DELTA = 180;

// zoom/position dependant
var mapX = 0;
var mapY = 0;
var mapWidth = 800; //Stage.width; 
var mapHeight = mapWidth/2; //lock aspect

	
	this._parent.map._x = mapX;
	this._parent.map._y = mapY;
	this._parent.map._width = mapWidth;
	this._parent.map._height = mapHeight;
	this._parent.map.setMask(msk);
	
	
// plot dots when button is pressed
this._parent.generateButton.onRelease = function() {

	//trace(rs.getLength());
	fields = rs.getColumnNames();
	for(var i=0; i<rs.getLength(); i++){
		//trace(rs.getItemAt(i)[fields[0]] + " , " + rs.getItemAt(i)[fields[1]]);
		//imageId = rs.getItemAt(i)[fields[0]];
		imageLat = rs.getItemAt(i)[fields[0]];
		imageLong = rs.getItemAt(i)[fields[1]];
		//this._parent.traceTxt.text = Stage.width;
		//mapWidth = 600;
		//mapHeight = 298;
		
		//convert longitude & latitude to screen cordinates
		//for max precision latitude/longitude incr < lat/long delta/stage hight/width respectively
		//4 sigfigs ain't bad then for my purposes, 5 would be better though
		imageX = mapX + Math.round(((number(imageLong) + Math.abs(LONG_INIT)) * (mapWidth / LONG_DELTA)));
		imageY = mapY + Math.round((((number(imageLat) * -1) + Math.abs(LAT_INIT)) * (mapHeight / LAT_DELTA)));
		
		//duplicate movieclip for each image location
		//duplicateMovieClip(this._parent.dot, imageId, 1);
		this._parent.attachMovie("dot", i, i);
		//trace(mc);
		this._parent[i]._x = imageX;
		this._parent[i]._y = imageY;
		//setProperty(this._parent.imageId, _x, imageX);
		//setProperty(this._parent.imageId, _y, imageY);
	}
	
}
package metaswarm.swarm.patterns   {
import flash.display.*;
import flash.utils.*;
import flash.events.*;
import flash.geom.*;
import flash.text.*;

	public class TypeMaker extends Sprite {
		
		//minimum size that text can be rastered at to provide
		//adequate sampling for large display
		private static const FONTSIZE:Number = 42;
		
		public function TypeMaker():void{
		}
		
		//given a text string, number of times to sample it, and desired width of output
		//returns a matrix of 2d coordinates
		public function make(strToSample:String, numOfSamples:uint, outputWidth:Number):Array
		{
			var coords:Array = new Array();
			var bitmap:Bitmap = new Bitmap();
			
			bitmap = raster(strToSample, FONTSIZE);
			coords = sample(bitmap, numOfSamples, outputWidth);
			
			return coords;
		}
		
		private function raster(strToRaster:String, sizeToRasterAt:uint):Bitmap
		{
			//bitmap obj to draw text onto
			var bitmapData:BitmapData;
			
			// Create the text
			var txt:TextField = new TextField( );
			txt.text = strToRaster;
			txt.autoSize = TextFieldAutoSize.LEFT;
			
			var fmt:TextFormat = new TextFormat( );
			fmt.size = sizeToRasterAt;
			fmt.font = "Arial Black";
			fmt.color = 0x000000;
			
			txt.setTextFormat(fmt);
			
			// Make the BitmapData object, sized to accommodate the text. transp is false.
			bitmapData = new BitmapData(txt.textWidth, txt.textHeight, false, 0xffffff);
			
			// Draw the text into the BitmapData object
			bitmapData.draw(txt);
			
			// Associate the BitmapData object with a Bitmap object
			var bitmap:Bitmap = new Bitmap(bitmapData);
			
			return bitmap;	
		}
		
		private function sample(bitmapToSample:Bitmap, numOfSamples:uint, outputWidth:uint):Array
		{
			//matrix of 2d coordinate arrays to return
			var points:Array = new Array();
			
			//bitmapData to sample
			var bitmapData:BitmapData = bitmapToSample.bitmapData;
			
			//brute force determination number of black pixels
			var numOfBlkPixels:uint = 0;
			for (var i:uint=0; i<bitmapData.width; i++){
				for (var j:uint=0; j<bitmapData.height; j++){
					//trace(bitmapData.getPixel(i,j));
					if(bitmapData.getPixel(i,j) == 0){
						numOfBlkPixels ++;
					}
				}
			}
			
			//calc sample step and scale factor to scale output to desired size
			var step:Number = Math.sqrt(numOfBlkPixels / numOfSamples);
			var sf:Number = outputWidth / bitmapData.width;
			
			//resample img every step pixels
			var count:uint = 0;
			for (var m:Number=0; m<bitmapData.width; m+=step){
				for (var n:Number=0; n<bitmapData.height; n+=step){
					if(bitmapData.getPixel(m,n) == 0){
						var nextPoint:Array = [m*sf, n*sf];
						//trace("next point: " + m*sf + ", " + n*sf);
						points.push(nextPoint);
						count++
					}
				}
			}
			
			//check variables
			/*trace("numOfBlkPixels: " + numOfBlkPixels);
			trace("numOfSamples: " + numOfSamples);
			trace("step: " + step);
			trace("sf: " + sf);
			trace("count: " + count);*/
			
			//return coordinates of new blk pixels
			return points;
		}
		
	}//end class
}//end pkg
package metaswarm.swarm.swarmstates {
	import metaswarm.swarm.Swarm;
	import metaswarm.swarm.SwarmState;
	
	public class BrowningState implements SwarmState{
		
		private static const BROWNING:Number = 2;
		
		private var swarm:Swarm;
		
		public function BrowningState(swarm:Swarm)
		{
			//trace("construct GridState");
			this.swarm = swarm;
			init();
		}	
		public function init():void{
			//genPattern();
		}
		public function incrState():void{
			//trace("ScatterState setPattern");
			swarm.swarmState = swarm.lorenze;
			swarm.setPattern();
		}
		public function decrState():void{
			//trace("ScatterState setPattern");
			swarm.swarmState = swarm.scatter;
			swarm.setPattern();
		}
		//make this private
		public function setPattern():void{
			//trace("GridState setPattern");
			for(var i:uint=0; i<swarm.nodeCnt; i++){
				swarm.nodes[i].setTarget(BROWNING, swarm.sortOrder);
			}
		}
		
	}//end class
}//end pkg
package metaswarm.swarm.swarmstates   {
	import metaswarm.swarm.Swarm;
	import metaswarm.swarm.SwarmState;
	
	public class GridState implements SwarmState{
		
		private static const GRID:Number = 0;
		
		private var swarm:Swarm;
		
		public function GridState(swarm:Swarm)
		{
			//trace("construct GridState");
			this.swarm = swarm;
			init();
		}	
		public function init():void{
			//genPattern();
		}
		public function incrState():void{
			//trace("ScatterState setPattern");
			swarm.swarmState = swarm.scatter;
			swarm.setPattern();
		}
		public function decrState():void{
			//trace("ScatterState setPattern");
			swarm.swarmState = swarm.map;
			swarm.setPattern();
		}
		//make this private
		public function setPattern():void{
			//trace("GridState setPattern");
			/*var prev:String = new String();
			prev = "";*/
			for(var i:uint=0; i<swarm.nodeCnt; i++){
				swarm.nodes[i].setTarget(GRID, swarm.sortOrder);
				/*if(swarm.nodes[i].tag.t.text == prev){
					swarm.nodes[i].tag.visible = false;
				}else{
					swarm.nodes[i].tag.visible = true;
				}
				prev = swarm.nodes[i].tag.t.text;*/
			}
		}
		
	}//end class
}//end pkg
package metaswarm.swarm.swarmstates   {
	import metaswarm.swarm.Swarm;
	import metaswarm.swarm.SwarmState;
	
	public class LorenzeState implements SwarmState{
		
		private static const LORENZE:int = 3;
		
		private var swarm:Swarm;
		
		public function LorenzeState(swarm:Swarm)
		{
			//trace("construct GridState");
			this.swarm = swarm;
			init();
		}	
		public function init():void{
			//genPattern();
		}
		public function incrState():void{
			//trace("ScatterState setPattern");
			swarm.swarmState = swarm.type;
			swarm.setPattern();
		}
		public function decrState():void{
			//trace("ScatterState setPattern");
			swarm.swarmState = swarm.browning;
			swarm.setPattern();
		}
		//make this private
		public function setPattern():void{
			//trace("GridState setPattern");
			for(var i:uint=0; i<swarm.nodeCnt; i++){
				swarm.nodes[i].setTarget(LORENZE, swarm.sortOrder);
			}
		}
		
	}//end class
}//end pkg
package metaswarm.swarm.swarmstates   {
	import metaswarm.swarm.Swarm;
	import metaswarm.swarm.SwarmState;
	
	public class MapState implements SwarmState{
		
		private static const MAP:Number = 5;
		
		private var _swarm:Swarm;
		
		public function MapState(swarm:Swarm)
		{
			//trace("construct ScatterState");
			this._swarm = swarm;
			init();
		}
		public function init():void{
			//do nothing
		}
		public function incrState():void{
			//trace("ScatterState setPattern");
			_swarm.swarmState = _swarm.grid;
			_swarm.setPattern();
		}
		public function decrState():void{
			//trace("ScatterState setPattern");
			_swarm.swarmState = _swarm.type;
			_swarm.setPattern();
		}
		public function setPattern():void{
			//trace("ScatterState setPattern");
			for(var i:uint=0; i<_swarm.nodeCnt; i++){
				_swarm.nodes[i].setTarget(MAP, _swarm.sortOrder);
			}
		}
		
	}//end class
}//end pkg
package metaswarm.swarm.swarmstates   {
	import metaswarm.swarm.Swarm;
	import metaswarm.swarm.SwarmState;
	
	public class ScatterState implements SwarmState{
		
		private static const SCATTER:Number = 1;
		
		private var swarm:Swarm;
		
		public function ScatterState(swarm:Swarm)
		{
			//trace("construct ScatterState");
			this.swarm = swarm;
			init();
		}
		public function init():void{
			//do nothing
		}
		public function incrState():void{
			//trace("ScatterState setPattern");
			swarm.swarmState = swarm.browning;
			swarm.setPattern();
		}
		public function decrState():void{
			//trace("ScatterState setPattern");
			swarm.swarmState = swarm.grid;
			swarm.setPattern();
		}
		public function setPattern():void{
			//trace("ScatterState setPattern");
			for(var i:uint=0; i<swarm.nodeCnt; i++){
				swarm.nodes[i].setTarget(SCATTER, swarm.sortOrder);
			}
		}
		
	}//end class
}//end pkg
package metaswarm.swarm.swarmstates   {
	import metaswarm.swarm.Swarm;
	import metaswarm.swarm.SwarmState;
	
	public class TypeState implements SwarmState{
		
		private static const TYPE:Number = 4;
		
		private var swarm:Swarm;
		
		function TypeState(swarm:Swarm)
		{
			//trace("construct GridState");
			this.swarm = swarm;
			init();
		}	
		public function init():void{
			//genPattern();
		}
		public function incrState():void{
			//trace("ScatterState setPattern");
			swarm.swarmState = swarm.map;
			swarm.setPattern();
		}
		public function decrState():void{
			//trace("ScatterState setPattern");
			swarm.swarmState = swarm.lorenze;
			swarm.setPattern();
		}
		//make this private
		public function setPattern():void{
			//trace("GridState setPattern");
			for(var i:uint=0; i<swarm.nodeCnt; i++){
				swarm.nodes[i].setTarget(TYPE, swarm.sortOrder);
			}
		}
		
	}//end class
}//end pkg
package metaswarm.ui   
{
    import flash.display.*;
	import flash.events.*;
	import flash.ui.Keyboard;
	import flash.net.*;
	import flash.utils.*;
	import flash.text.*;
	import metaswarm.ui.hoverlabel.HoverLabel;
	import metaswarm.ui.log.Log;
	import metaswarm.ui.sidebar.Sidebar;
	import metaswarm.swarm.Swarm;
	import metaswarm.ui.uistates.AboutState;
	import metaswarm.ui.uistates.ContactState;
	import metaswarm.ui.uistates.ExploreState;
	import metaswarm.ui.uistates.PreviewState;

	//import fl.controls.Label;
	
	//UI
    public class Ui extends Sprite
    {	
		public var w:int;
		public var h:int;
		
		public var swarm:Swarm;
		public var sidebar:Sidebar;
		public var hoverLabel:HoverLabel;
		public var cmdLog:Log;
		//public var lastCmd:Label;
		
		//internal states
		public var explore:UiState;
		public var preview:UiState;
		public var about:UiState;
		//public var contact:UiState;
		
		//internal state holder
		public var uiState:UiState;
		
        public function Ui():void
		{
			swarm = new Swarm();
			sidebar = new Sidebar();
			hoverLabel = new HoverLabel();
			//lastCmd = new Label();
			cmdLog = new Log();
			
			explore = new ExploreState(this);
			preview = new PreviewState(this);
			about = new AboutState(this);
			//contact = new ContactState(this);
			
			uiState = explore;
		
			init();
		}
		public function init():void{ 
			//can't access this.stage until main is added to stage
			//so listen for event then use stage
			addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);
		}
		
		public function onAddedToStage(event:Event):void
		{
			swarm.x = stage.stageWidth/6;
			swarm.y = stage.stageHeight/6;
			swarm.w = stage.stageWidth*(2/3);
			swarm.h = stage.stageHeight*(2/3);
		}
	
    }//end class
}//end pkg
package metaswarm.ui 
{	
	import metaswarm.*;
	import metaswarm.swarm.SwarmLoader;
	import metaswarm.swarm.patternmaker.PatternMaker;
	import metaswarm.ui.hoverlabel.LabelMaker;
	import metaswarm.ui.log.LogMaker;
	import metaswarm.ui.sidebar.SidebarMaker;
	
	public class UiLoader 
	{	
		private var _ui:Ui;
		private var _labelMaker:LabelMaker;
		private var _sidebarMaker:SidebarMaker;
		private var _patternMaker:PatternMaker;
		private var _logMaker:LogMaker;
		
		public function UiLoader(main:Ui) {
			this._ui = main;
			this._patternMaker = new PatternMaker(_ui.swarm);
			this._labelMaker = new LabelMaker(_ui.hoverLabel);
			this._sidebarMaker = new SidebarMaker(_ui.sidebar);
			this._logMaker = new LogMaker(_ui.cmdLog);
			init();
		}
		
		private function init():void { 
			//  
		}
		
		public function load(dat:Array):void{
			//trace("main.load()");
			var swarmLoader:SwarmLoader = new SwarmLoader(_ui.swarm); //<------------------------------------not sure about this
			swarmLoader.load(dat);
		}
		public function make():void{
			//trace("main.make()");
			var swarmLoader:SwarmLoader = new SwarmLoader(_ui.swarm); //<------------------------------------not sure about this
			swarmLoader.make();
			_labelMaker.make();
			_patternMaker.make();
			_sidebarMaker.make();
			_logMaker.make();
		}
		public function go():void{
			//trace("main.go()");
			var swarmLoader:SwarmLoader = new SwarmLoader(_ui.swarm); //<------------------------------------not sure about this
			swarmLoader.go();
			_labelMaker.go();
			_sidebarMaker.go();
			_logMaker.go();
			
			
			_ui.addChild(_ui.swarm);
			_ui.addChild(_ui.hoverLabel);
			_ui.addChild(_ui.sidebar);
			_ui.addChild(_ui.cmdLog);
			
			//set initial pattern
			_ui.swarm.setPattern();
		}
	}
}
package metaswarm.ui {
	
	//fsm interface
	public interface UiState{
		
		//internal interface methods
		function onEnterFrame():void;
		function onRightKey():void;
		function onLeftKey():void;
		function onUpKey():void;
		function onDownKey():void;
		function onSpaceKey():void;
		function onKey1():void;
		function onKey2():void;
		function onKey3():void;
		function onKey4():void;
		function onMouseClick(node:Node, button:Object):void;
		function onCtrlClick(node:Node, button:Object):void;
		function onShftClick(node:Node, button:Object):void;
		function onAltClick(node:Node, button:Object):void;
		function onCtrlShftClick(node:Node, button:Object):void;
		//function onDataBoxClick(node:Node, button:Object):void;
		function onMouseDown(node:Node, button:Object):void;
		function onMouseUp(target:Node):void;
		function onMouseOver(target:Node, button:Object):void;
		function onCtrlOver(target:Node, button:Object):void;
		function onShftOver(target:Node, button:Object):void;
		function onCtrlShftOver(node:Node, button:Object):void;
		function onCtrlOut():void;
		function onShftOut():void;
		function onCtrlShftOut():void;
		function onMouseOut(target:Node):void;
	
	}//end interface
}//end pkg
		
package metaswarm.ui.hoverlabel {
	import flash.display.*;
	import flash.text.*;
	
	public class HoverLabel extends Sprite{
		
		//add formatting constants here
		public var labelMaker:LabelMaker;
		public var _output:TextField;
		public var _text:String;
		
		public function HoverLabel():void
		{
			_output = new TextField();
			_text = new String();
			labelMaker = new LabelMaker(this);
			
			init();
		}
		public function init():void {
			visible = true;
			focusRect = false;
			tabEnabled = false;
			mouseEnabled = false;
		}
		
		/*public function load():void{
			//
		}
		public function make():void{
			labelMaker.make();
		}
		public function go():void{
			labelMaker.go();
		}*/
		
		public function get text():String {
            return _text;
        }
        public function set text(newText:String):void {
        	_text = newText; 
		}
		
		public function update():void{
			_output.x = mouseX + 15;
			_output.y = mouseY + 5;
			_output.text = _text;
		}
		
		public function show():void{
			_output.visible = true;
		}
		
		public function hide():void{
			_output.visible = false;
		}
			
		
	}//end class
}//end pkg
package metaswarm.ui.hoverlabel {
	import flash.display.*;
	import flash.text.*;
	
	public class LabelMaker extends Sprite{
		
		private var hl:HoverLabel;
		
		public function LabelMaker(hoverLabel:HoverLabel):void{
			this.hl = hoverLabel;
			init();
		}
		public function init():void {
			//
		}
		public function make():void {
			//var fmt:TextFormat = new TextFormat( );
			var fmt:TextFormat = new TextFormat("Technic", 10, 0xfff);

			//tag.t.embedFonts = true;
			//tag.t.antiAliasType = AntiAliasType.ADVANCED;
			hl._output.text = "";
			hl._output.setTextFormat(fmt);
			hl._output.selectable = false;
			hl._output.mouseEnabled = false;
			//log.id = 0;
			
			//t.width = 
			//t.height =
			hl._output.background = true
			hl._output.backgroundColor = 0xf0ff64; //black
			//t.border = true;
			//t.borderColor = 0x333333; //dark gray
			hl._output.autoSize = TextFieldAutoSize.LEFT;
			//addChild(this);
			
			//tag.t.text = tag.dat[tag.id];
			
			
		}
		
		public function go():void {
			hl.addChild(hl._output);
		}
	}
}
package metaswarm.ui.log {
	import flash.display.*;
	import flash.text.*;
	
	public class Log extends Sprite{
		
		//add formatting constants here
		//public var logMaker:LogMaker;
		public var output:TextField;
		public var entries:Array;
		
		public function Log():void
		{
			output = new TextField();
			//logMaker = new LogMaker(this);
			entries = new Array();
			
			init();
		}
		public function init():void {
			visible = true;
			focusRect = false;
			tabEnabled = false;
			//tag.mouseEnabled = false;
		}
		
		public function load():void{
			//
		}
		public function make():void{
			//logMaker.make();
		}
		
		public function append(txt:String):void{
			trace("txt: " + txt);
			trace("entries[" + entries.length + "]: " + entries[entries.length-1]);
			
			trace("_");
			
			entries.push(txt);
			//output.unshift(txt + '\n');
			output.replaceText(0, 0, txt + '\n');
			
			/*
			if(txt != entries[entries.length-1]){
				trace("log it");
				entries.push(txt);
				//output.appendText(txt + '\n');
				//output.unshift(txt + '\n');
				output.replaceText(0, 0, txt + '\n');
			}else{
				//entries.push(txt);
				//output.appendText(entries.pop() + '\n');
				//output.text = entries.pop();
			}
			*/
		}
			
		
	}//end class
}//end pkg
package metaswarm.ui.log {
	import flash.display.*;
	import flash.text.*;
	
	public class LogMaker extends Sprite{
		
		private var _log:Log;
		
		public function LogMaker(log:Log):void{
			this._log = log;
			init();
		}
		public function init():void {
			//
		}
		public function make():void {
			//var fmt:TextFormat = new TextFormat( );
			
			var fmt:TextFormat = new TextFormat("Technic", 10, 0xfff);
			//fmt.color = 0xfff;
			//tag.t.embedFonts = true;
			//tag.t.antiAliasType = AntiAliasType.ADVANCED;
			_log.output.text = "";
			_log.output.setTextFormat(fmt);
			_log.output.selectable = false;
			_log.output.mouseEnabled = false;
			//log.id = 0;
			
			//t.width = 
			//t.height =
			//_log.output.background = true
			//_log.output.backgroundColor = 0x999999; //light gray
			//t.border = true;
			//t.borderColor = 0x333333; //dark gray
			_log.output.autoSize = TextFieldAutoSize.LEFT;
			//addChild(this);
			
			//tag.t.text = tag.dat[tag.id];
			
			_log.output.x=1100;
			_log.output.y=0;
		}
		public function go():void {
			_log.addChild(_log.output);
		}
	}
}
package metaswarm.ui.sidebar {
	import flash.display.*;
	import flash.text.*;
	
	public class Sidebar extends Sprite{
		
		public var sidebarMaker:SidebarMaker;
		//
		public var header:TextField;
		public var shortcuts:TextField;
		public var states:TextField;
		public var nodeList:TextField;
		public var footer:TextField;
		
		public function Sidebar():void
		{
			header = new TextField();
			shortcuts = new TextField();
			states = new TextField();
			nodeList = new TextField();
			footer = new TextField();
			
			sidebarMaker = new SidebarMaker(this);
			
			init();
		}
		public function init():void {
			//
		}
		public function load():void{
			//
		}
		public function make():void{
			sidebarMaker.make();
		}
			
		
	}//end class
}//end pkg
package metaswarm.ui.sidebar {
	import flash.display.*;
	import flash.geom.ColorTransform;
	import flash.text.*;
	
	public class SidebarMaker extends Sprite{
		
		public var sb:Sidebar;
		
		public function SidebarMaker(sidebar:Sidebar):void{
			this.sb = sidebar;
			init();
		}
		public function init():void {
			//
		}
		public function make():void {
			
			var h1fmt:TextFormat = new TextFormat( );
			h1fmt.font = "technic";
			h1fmt.size = 12;
			h1fmt.leftMargin = 10;
			
			var fmt:TextFormat = new TextFormat( );
			fmt.font = "technic";
			fmt.size = 12;
			fmt.leftMargin = 10;

			// ************************************** shared properties
			/*
			var bg:ColorTransform;
			bg.color = 0xFAFAFA;
			var border:ColorTransform;
			border.color = 0xE6E6E6; 
			*/
			var sbWidth:int = 180;
			
			// **************************************
			sb.header.text = '\n' + "meta.swarm" + '\n\n';
			sb.header.setTextFormat(h1fmt);
			sb.header.selectable = false;
			sb.header.mouseEnabled = false;
			sb.header.x=0;
			//sb.header.y=0;
			sb.header.width = sbWidth;
			sb.header.height = 40;
			//sb.header.autoSize = TextFieldAutoSize.CENTER;
			sb.header.background = true;
			sb.header.backgroundColor = 0xFAFAFA;
			sb.header.border = true; 
			sb.header.borderColor = 0xE6E6E6;
			
			// **************************************
			sb.shortcuts.text = " " + '\n' +
								"navigation" + '\n\n' +
								"^ - increment sort" + '\n' +
								"v - decrement sort" + '\n' +
								"> - increment pattern" + '\n' +
								"< - decrement pattern" + '\n\n';
			sb.shortcuts.setTextFormat(fmt);
			sb.shortcuts.selectable = false;
			sb.shortcuts.mouseEnabled = false;
			sb.shortcuts.x = 0;
			//sb.shortcuts.y = 0;
			sb.shortcuts.width = sbWidth;
			sb.shortcuts.height = 120;
			//sb.shortcuts.autoSize = TextFieldAutoSize.CENTER;
			sb.shortcuts.background = true;
			sb.shortcuts.backgroundColor = 0xFAFAFA; //light gray
			sb.shortcuts.border = true;
			sb.shortcuts.borderColor = 0xE6E6E6;
			
			//  **************************************
			sb.states.text = " " + '\n' + 
							 "selection" + '\n\n' +
							 "r - select / deselect" + '\n' +
							 "ctrl + r - add / remove" + '\n' +
							 "shft + r -  select by" + '\n' +
							 "ctrl&shft + r - filter by" + '\n\n';
			sb.states.setTextFormat(fmt);
			sb.states.selectable = false;
			sb.states.mouseEnabled = false;
			sb.states.width = sbWidth;
			sb.states.height = 110;
			//sb.states.autoSize = TextFieldAutoSize.LEFT;
			sb.states.background = true;
			sb.states.backgroundColor = 0xFAFAFA; //light gray
			sb.states.border = true;
			sb.states.borderColor = 0xE6E6E6;
			
			// **************************************
			sb.nodeList.text = '\n' + "nodes" + '\n\n';
			sb.nodeList.setTextFormat(fmt);
			sb.nodeList.selectable = false;
			sb.nodeList.mouseEnabled = false;
			//sb.nodeList.scrollV = 1;
			sb.nodeList.width = sbWidth;
			sb.nodeList.height = 900 - (sb.header.textHeight + 
										sb.shortcuts.textHeight + 
										sb.states.textHeight +
										sb.footer.textHeight);
			//sb.nodeList.autoSize = TextFieldAutoSize.LEFT;
			sb.nodeList.background = true;
			sb.nodeList.backgroundColor = 0xFAFAFA; //light gray
			sb.nodeList.border = true;
			sb.nodeList.borderColor = 0xE6E6E6;
			
			// **************************************
			sb.footer.text = '\n' + "by boot" + '\n\n';
			sb.footer.setTextFormat(fmt);
			sb.footer.selectable = false;
			sb.footer.mouseEnabled = false;
			sb.footer.width = sbWidth;
			sb.footer.height = 40;
			//sb.footer.autoSize = TextFieldAutoSize.LEFT;
			sb.footer.background = true;
			sb.footer.backgroundColor = 0xFAFAFA; //light gray
			sb.footer.border = true;
			sb.footer.borderColor = 0xE6E6E6;
			
			// **************************************
			sb.header.y = 0;
			sb.shortcuts.y = sb.header.height;
			sb.states.y = sb.shortcuts.y + sb.shortcuts.height;
			sb.nodeList.y = sb.states.y + sb.states.height;
			sb.footer.y = 900 - sb.footer.height;
			
		}
		
		public function go():void {
			sb.addChild(sb.header);
			sb.addChild(sb.shortcuts);
			sb.addChild(sb.states);
			sb.addChild(sb.nodeList);
			sb.addChild(sb.footer);
		}
	}
}
package metaswarm.ui.uistates   {
	import metaswarm.ui.Ui;
	import metaswarm.ui.UiState;
	
	public class AboutState implements UiState{
		
		private var main:Ui;
		
		public function AboutState(main:Ui)
		{
			//trace("construct ExploreState");
			this.main = main;
			init();
		}	
		private function init():void{
		}
		
		//delegated methods*********************************************
		public function onEnterFrame():void{
		}
		public function onRightKey():void{
		}
		public function onLeftKey():void{
		}
		public function onUpKey():void{
		}
		public function onDownKey():void{
		}
		public function onSpaceKey():void{
			//main.mainState = main.xxx;
		}
		public function onKey1():void{
			//main.picked.restore();
			//main.mainState = main.explore;
		}
		public function onKey2():void{
			//main.picked.restore();
			//main.dropped.tile();
			//main.mainState = main.preview;
		}
		public function onKey3():void{
			//main.mainState = main.about;
		}
		public function onKey4():void{
			//main.mainState = main.contact;
		}
		public function onMouseClick(node:Node, button:Object):void{
		}
		public function onCtrlClick(node:Node, button:Object):void{
		}
		public function onShftClick(node:Node, button:Object):void{
		}
		public function onAltClick(node:Node, button:Object):void{
		}
		public function onCtrlShftClick(node:Node, button:Object):void{
		}
		public function onCtrlShftOver(node:Node, button:Object):void{
		}
		public function onCtrlShftOut():void{
		}
		public function onMouseDown(node:Node, button:Object):void{
			//target.drag();
		}
		public function onMouseUp(target:Node):void{
			//target.drop();
		}
		public function onMouseOver(target:Node, button:Object):void{
			//target.startPrev();
		}
		public function onCtrlOver(target:Node, button:Object):void{
			//target.startPrev();
		}
		public function onShftOver(target:Node, button:Object):void{
			//target.startPrev();
		}
		public function onCtrlOut():void{
			//target.startPrev();
		}
		public function onShftOut():void{
			//target.startPrev();
		}
		public function onMouseOut(target:Node):void{
			//target.stopPrev();
		}

		
	}//end class
}//end pkg
package metaswarm.ui.uistates   {
	import metaswarm.ui.Ui;
	import metaswarm.ui.UiState;
	
	class ContactState implements UiState{
		
		var main:Ui;
		
		function ContactState(main:Ui)
		{
			//trace("construct ExploreState");
			this.main = main;
			init();
		}	
		public function init():void{
		}
		
		//delegated methods*********************************************
		public function onEnterFrame():void{
		}
		public function onRightKey():void{
		}
		public function onLeftKey():void{
		}
		public function onUpKey():void{
		}
		public function onDownKey():void{
		}
		public function onSpaceKey():void{
			//main.mainState = main.xxx;
		}
		public function onKey1():void{
			//main.mainState = main.explore;
		}
		public function onKey2():void{
			//main.mainState = main.preview;
		}
		public function onKey3():void{
			//main.mainState = main.about;
		}
		public function onKey4():void{
			//main.mainState = main.contact;
		}
		public function onMouseClick(node:Node, button:Object):void{
		}
		public function onCtrlClick(node:Node, button:Object):void{
		}
		public function onShftClick(node:Node, button:Object):void{
		}
		public function onAltClick(node:Node, button:Object):void{
		}
		public function onCtrlShftClick(node:Node, button:Object):void{
		}
		public function onCtrlShftOver(node:Node, button:Object):void{
		}
		public function onCtrlShftOut():void{
		}
		public function onMouseDown(node:Node, button:Object):void{
			//target.drag();
		}
		public function onMouseUp(target:Node):void{
			//target.drop();
		}
		public function onMouseOver(target:Node, button:Object):void{
			//target.startPrev();
		}
		public function onCtrlOver(target:Node, button:Object):void{
			//target.startPrev();
		}
		public function onShftOver(target:Node, button:Object):void{
			//target.startPrev();
		}
		public function onCtrlOut():void{
			//target.startPrev();
		}
		public function onShftOut():void{
			//target.startPrev();
		}
		public function onMouseOut(target:Node):void{
			//target.stopPrev();
		}

		
	}//end class
}//end pkg
package metaswarm.ui.uistates {
	import metaswarm.*;
	import metaswarm.ui.Ui;
	import metaswarm.swarm.Swarm;
	import metaswarm.ui.UiState;
	
	public class ExploreState implements UiState{
		
		private var main:Ui;
		
		public function ExploreState(main:Ui)
		{
			//trace("construct ExploreState");
			this.main = main;
			init();
		}	
		public function init():void{
		}
		
		//delegated methods**************************************************
		public function onEnterFrame():void{
			main.swarm.rePosition();
			main.swarm.reSize();
			main.hoverLabel.update();
		}
		public function onRightKey():void{
			main.swarm.incrState();
			main.cmdLog.append("next pattern");
			//main.lastCmd.text = "next pattern";
		}
		public function onLeftKey():void{
			main.swarm.decrState();
			main.cmdLog.append("previous pattern");
		}
		public function onUpKey():void{
			main.swarm.incrSort();
			main.cmdLog.append("increment sort");
		}
		public function onDownKey():void{
			main.swarm.decrSort();
			main.cmdLog.append("increment sort");
		}
		public function onSpaceKey():void{
			//main.dropped.tile(); //could move to preview state onEnterFrame
			//main.mainState = main.preview;
			main.swarm.dropSelected();
			main.cmdLog.append("drop selected");
		}
		public function onKey1():void{
			//
		}
		public function onKey2():void{
			trace("ExploreState->onKey2");
			main.swarm.preview();
			main.uiState = main.preview;
			main.cmdLog.append("preview mode");
		}
		public function onKey3():void{
			//main.mainState = main.about;
		}
		public function onKey4():void{
			//main.mainState = main.contact;
		}
		public function onCtrlClick(node:Node, button:Object):void
		{
			switch (button.type) {
				case "dot":
					//dot clear and select
					//main.swarm.add(node);
					//main.cmdLog.append("add/remove to selection");
					//tag clear and selectby
					main.swarm.add(node);
					//main.swarm.addBy(node.tag.t.text);
					main.cmdLog.append("add node: " + node.dat[0] + node.dat[1]);
					break;
				case "icon":
					//tag clear and selectby
					main.swarm.remove(node);
					main.cmdLog.append("remove node: " + node.dat[0] + node.dat[1]);
					break;
				case "tag":
					//main.swarm.addBy(node.tag.t.text);
					break;
				default:
					trace("oops, you ctrl clicked button of type: " + button.type);
			}
		}
		public function onShftClick(node:Node, button:Object):void
		{
			switch (button.type) {
				case "dot":
					//main.swarm.filterBy(node.tag.t.text);
					//main.cmdLog.append("filter by: " + node.tag.t.text);
					main.swarm.selectBy(node.tag.t.text);
					main.cmdLog.append("select by: " + node.tag.t.text);
					break;
				case "icon":
					//
					//main.swarm.xxx(node);
					main.swarm.selectBy(node.tag.t.text);
					main.cmdLog.append("select by: " + node.tag.t.text);
					break;
				case "tag":
					/*main.swarm.filterBy(node.tag.t.text);
					main.cmdLog.append("filter by: " + node.tag.t.text);*/
					break;
				default:
					trace("damn it, you shft clicked button of type: " + button.type);
			}
		}
		public function onAltClick(node:Node, button:Object):void
		{
			//can't use alt b/c window uses it to focus toolbar
		}
		public function onCtrlShftClick(node:Node, button:Object):void
		{
			switch (button.type) {
				case "dot":
					//
					break;
				case "icon":
					//
					main.swarm.filterBy(node.tag.t.text);
					main.cmdLog.append("filter by: " + node.tag.t.text);
					break;
				case "tag":
					//
					break;
				default:
					trace("shit, you shft clicked button of type: " + button.type);
			}
		}
		public function onMouseClick(node:Node, button:Object):void
		{
			switch (button.type) {
				case "dot":
					//dot clear and select
					main.swarm.select(node);
					main.cmdLog.append("select node: " + node.dat[0] + node.dat[1]);
					break;
				case "icon":
					//tag clear and selectby
					//main.swarm.selectBy(node.tag.t.text);
					//main.cmdLog.append("select by: " + node.tag.t.text);
					//DO NOTHING B/C drag will handle this case! <------------------------NOTE
					break;
				case "tag":
					//
					//main.swarm.xxx(node);
					main.swarm.selectBy(node.tag.t.text);
					//main.cmdLog.append("filter by: " + node.tag.t.text);
					break;
				case "popout": //rename popoutData
					//trace("popout");
					main.swarm.popout(node);
					break;
				case "popin":
					//trace("popin");
					main.swarm.popin(node);
					break;
				case "closeThumb":
					//
					main.swarm.close(node);
					break;
				default:
					//trace("Not a valid type of button");
			}
		}
		
		//public function onDataBoxClick(node:Node, button:Object):void{}
		
		public function onMouseDown(node:Node, button:Object):void
		{
			switch (button.type) {
				case "icon":
					//
					main.swarm.drag(node); //should be dragIcon!!
					main.cmdLog.append("drag " + node.dat[0] + node.dat[1]);
					break;
				case "bmp":
					main.swarm.drag(node); //should be dragThumb!!
					main.cmdLog.append("drag " + node.dat[0] + node.dat[1]);
					break;
				default:
					//break
			}
		}
		public function onMouseUp(node:Node):void{
			main.swarm.drop(node);
		}
		
		//over
		public function onMouseOver(node:Node, button:Object):void{
			main.hoverLabel.show();
			main.swarm.startHover(node);
			//main.cmdLog.append("start hover");
			//main.swarm.startFocus(target.tag.t.text);

			switch (button.type) {
				case "dot":
					main.hoverLabel.text = "select " + node.dat[0] + node.dat[1];
					break;
				case "icon":
					main.hoverLabel.text = "drag to pluck " + node.dat[0] + node.dat[1];
					break;
				case "tag":
					main.hoverLabel.text = "Clear and Select by: " + node.tag.t.text;
					break;
				case "popout": //rename popoutData
					main.hoverLabel.text = "show data for " + node.dat[0] + node.dat[1];
					break;
				case "popin":
					main.hoverLabel.text = "hide data for " + node.dat[0] + node.dat[1];
					break;
				case "closeThumb":
					main.hoverLabel.text = "close thumbnail and return " + node.dat[0] + node.dat[1] + " to the swarm";
					break;
				case "bmp":
					main.hoverLabel.text = "drag " + node.dat[0] + node.dat[1];
					break;
				default:
					//trace("Not a valid type of button");
			}
		}
		public function onCtrlOver(node:Node, button:Object):void{
			main.swarm.startHover(node);
			//main.cmdLog.append("start hover");
			//main.swarm.startFocusBy(node.tag.t.text);
			main.hoverLabel.text = "Add/remove " + node.dat[0] + node.dat[1];
		}
		public function onShftOver(node:Node, button:Object):void{
			main.swarm.startHover(node);
			main.swarm.startSelectByFocus(node.tag.t.text); //should be focusDotsBy
			main.hoverLabel.text = "Select by: " + node.tag.t.text;
		}
		public function onCtrlShftOver(node:Node, button:Object):void{
			main.swarm.startHover(node);
			main.swarm.startFilterByFocus(node.tag.t.text); //should be focusIconsBy
			main.hoverLabel.text = "Filter by: " + node.tag.t.text;
		}
		
		//out
		public function onMouseOut(node:Node):void{
			main.hoverLabel.hide();
			main.swarm.stopHover(node);
			//main.cmdLog.append("stop hover");
			//main.swarm.stopFocus(target.tag.t.text);
		}
		public function onCtrlOut():void{
			//main.swarm.startHover(node);
			main.swarm.stopFocusBy();
			//main.cmdLog.append("stopFocusBy");
		}
		public function onShftOut():void{
			//main.swarm.startHover(node);
			main.swarm.stopFocusBy();
			//main.cmdLog.append("stopFocusBy");
		}
		public function onCtrlShftOut():void{
			//
		}
		

	}//end class
}//end pkg
package metaswarm.ui.uistates   {
	import metaswarm.*;
	import metaswarm.ui.Ui;
	import metaswarm.ui.UiState;
	
	public class PreviewState implements UiState{
		
		private var main:Ui;
		
		function PreviewState(main:Ui)
		{
			//trace("construct ExploreState");
			this.main = main;
			init();
		}	
		public function init():void{
		}
		
		//delegated methods*********************************************
		public function onEnterFrame():void{
			main.swarm.rePosition();
			main.swarm.reSize();
			main.hoverLabel.update();
		}
		public function onRightKey():void{
		}
		public function onLeftKey():void{
		}
		public function onUpKey():void{
		}
		public function onDownKey():void{
		}
		public function onSpaceKey():void{
			//main.mainState = main.xxx;
		}
		public function onKey1():void{
			trace("previewState->onKey1");
			main.swarm.explore();
			main.uiState = main.explore;
		}
		public function onKey2():void{
			//main.mainState = main.preview;
		}
		public function onKey3():void{
			//main.mainState = main.about;
		}
		public function onKey4():void{
			//main.mainState = main.contact;
		}
		public function onMouseClick(node:Node, button:Object):void{
		}
		public function onCtrlClick(node:Node, button:Object):void{
		}
		public function onShftClick(node:Node, button:Object):void{
		}
		public function onAltClick(node:Node, button:Object):void{
		}
		public function onCtrlShftClick(node:Node, button:Object):void{
		}
		public function onCtrlShftOver(node:Node, button:Object):void{
		}
		public function onCtrlShftOut():void{
		}
		public function onMouseDown(node:Node, button:Object):void{
			//target.drag();
		}
		public function onMouseUp(target:Node):void{
			//target.drop();
		}
		public function onMouseOver(target:Node, button:Object):void{
			//target.startPrev();
		}
		public function onCtrlOver(target:Node, button:Object):void{
			//target.startPrev();
		}
		public function onShftOver(target:Node, button:Object):void{
			//target.startPrev();
		}
		public function onCtrlOut():void{
			//target.startPrev();
		}
		public function onShftOut():void{
			//target.startPrev();
		}
		public function onMouseOut(target:Node):void{
			//target.stopPrev();
		}

		
	}//end class
}//end pkg
